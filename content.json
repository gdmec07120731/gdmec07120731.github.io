{"meta":{"title":"ppjun's blog","subtitle":"Thanks for your watching","description":null,"author":"区汇君","url":"http://www.lanyimi.com"},"pages":[{"title":"tags","date":"2016-03-06T09:33:34.000Z","updated":"2016-03-06T09:33:34.872Z","comments":true,"path":"tags/index.html","permalink":"http://www.lanyimi.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2016-03-06T09:34:48.000Z","updated":"2016-03-06T09:34:48.169Z","comments":true,"path":"categories/index.html","permalink":"http://www.lanyimi.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2016-03-06T09:34:27.000Z","updated":"2016-03-06T10:14:23.815Z","comments":true,"path":"about/index.html","permalink":"http://www.lanyimi.com/about/index.html","excerpt":"","text":"一枚安卓程序猿"}],"posts":[{"title":"dataBinding?","slug":"dataBinding","date":"2017-09-06T01:48:26.000Z","updated":"2017-09-06T02:57:06.978Z","comments":true,"path":"2017/09/06/dataBinding/","link":"","permalink":"http://www.lanyimi.com/2017/09/06/dataBinding/","excerpt":"","text":"A : How to use Databinding? B: such as read this circle. ###Open setting First , open your file which is in app/build.gradle , and you can see the android’ field , you need to write the code like this to open the dataBinding’ Setting. 123456android &#123; ... dataBinding &#123; enabled = true &#125;&#125; ###Create a bean Second , create a bean which is named User in your package , and create two variable as well as generate their constroctor. Two variable , name and age , were String variable and int variable . you must use the public to decorate two variable ,otherwise it wiil catch the Exception such as like this : 1Could not find accessor package.User.name here are the full code 12345678910public class User &#123; public String name; public String age; public User(String name, String age) &#123; this.name = name; this.age = age; &#125;&#125; Modify the xmlThrid , add the label to root in your xml . by the way ,you need to write the android nameSpace in the layout element. create the label which in the label . create the label to import the User class which created juts now . create the label next to the with two property which is called name and type. you can write the name which just like user, and type must be call User . Now , you can give the text to TextView by Using anroid:text=”@{user.name}” here are the full code: 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"ja&gt;&lt;data&gt; &lt;import type=\"com.ppjun.android.databinding.User\"/&gt; &lt;variable name=\"user\" type=\"User\"/&gt; &lt;/data&gt;&lt;RelativeLayout android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_below=\"@+id/toolbar\" android:id=\"@+id/name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;user.name&#125;\" /&gt; &lt;TextView android:id=\"@+id/age\" android:layout_below=\"@+id/name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;user.age&#125;\"/&gt;&lt;/RelativeLayout&gt;&lt;/layout&gt; ###Connect to the data Final , gradle sync to generate the AcrivityMainBingding . In the MainActivity ‘onCreate method , create the AcrivityMainBingding binding by Using the method DataBindingUtil.setCotnentView(this,R.layout.activity_main); new the User variable by it’s constroctor. user binding.setUser(user); to binding the xml. here are the full code: 123ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);User user = new User(\"ppjun\", \"23\");binding.setUser(user); run the application you will see the TextView text like ppjun and 23. Summary DataBinding is easy for us to set the text without findviewbyid. The next article will show you more things about DataBinding. Thanks for your watching.:)","categories":[],"tags":[{"name":"dataBinding","slug":"dataBinding","permalink":"http://www.lanyimi.com/source/tags/dataBinding/"}]},{"title":"清远古龙峡漂流","slug":"piaoliu","date":"2017-05-30T17:46:52.000Z","updated":"2017-05-30T17:49:10.593Z","comments":true,"path":"2017/05/31/piaoliu/","link":"","permalink":"http://www.lanyimi.com/2017/05/31/piaoliu/","excerpt":"","text":"说到清远最出名的是漂流，走地鸡，并且有很多个各种大落差的峡可以去漂流。这次我们抱团和朋友共4人去到乘大巴去到清远清城区古龙峡。 开始【09:30】一行人在杨箕E1出口集合，并且开车到海珠广场装载第二批乘客【10:00】到达海珠广场，停留15分钟。【10:15】正式开车前往古龙峡，期间导游推销各种午餐，以及其公司的漂流道具店产品。这里最好最好最好是自备各种午餐（可以购买面包，零食，三明治，水），以及水上道具（水勺下面有说到），袋子（隔离湿衣服），因为考虑到卫生以及节约成本，提高旅游的幸福愉悦感，其中路过清泉湾，广州地铁上都有卖广告。里面有个大喇叭滑梯的，需要穿泳衣进场。【11:00】到达清远古龙峡。并且开始在小山上探险，为了折腾一下时间，因为漂流下午才开始。【11:30】就餐是导游推荐的烤鸡。这里我非常不推荐。第一贵售价68元，个人不喜欢吃，第二不知道卫不卫生，是不是黑作坊的产品。【12:30】30分钟的休息时间。【13:00】开始换衣服，穿拖鞋。把手机等贵重物品放在贵重的物品保管格子。【13:20】开始排队上山漂流。【15:00】经过1个多钟的等待终于山上，现场很多人（端午假期）。期间等了好几趟，接送的车辆，和运输皮艇救生衣的车辆上山。【15:10】穿好救生衣，戴好头盔，把水勺绑在救生衣上，2个人一只皮艇，抓紧皮艇左右扶手。开始漂流，一开始就有7-8米的落差，伴随着尖叫，顿时全身湿了，冰冷的泉水弄湿了身上的衣服，拖鞋也差点飞走。过程中还喝了不少水，再漂多几个落差后，熟悉了这样子的落差后就不用害怕了。每几个落差后，你都可以用水枪，水勺来泼水，其中水勺的爆发力强，选择妹子泼水。将近漂了几十分钟，从山顶漂到山脚了。【15:45】到底山脚，结束漂流。【16:00】换上干衣服，吃点小吃补充能量。【16:30】结束行程开车回广州【19:30】回到广州纪念堂，期间只有清远万达广场塞车。【20:00】去到公元前吃晚餐。【21:00】回宿舍了。 总结，一天的漂流： 漂流前自备大瓶水，午餐（面包，三明治，汽水，零食），多个袋子（隔离湿衣服），干衣服，全包裹拖鞋（防止被水冲走），水勺。 选择周末去跟团漂流，节假日排队时间比漂流时间都长。最后，附赠一张漂流照片留念。","categories":[],"tags":[{"name":"tourist","slug":"tourist","permalink":"http://www.lanyimi.com/source/tags/tourist/"}]},{"title":"16.04.2","slug":"16-04-2","date":"2017-05-27T12:51:27.000Z","updated":"2017-05-27T13:40:26.826Z","comments":true,"path":"2017/05/27/16-04-2/","link":"","permalink":"http://www.lanyimi.com/2017/05/27/16-04-2/","excerpt":"","text":"这节课我们讲iptables在ubuntu干啥子的，还有如果不想做网管的程序员，那么他就不是好的厨子。by the way如果想深入了解linux可以看一下鸟哥的私房菜，那是一本我14年一个人躲在小黑屋看过几页的书。下面是小弟的愚见，如果有什么不对，还请阁下斧正。 什么是iptablesiptables是用来设置、维护和检查Linux内核的IP包过滤规则的。就是一个ip防火墙，也就是说我们无论用什么端口访问别人还是别人用什么端口来访问我们，都要经过iptables的名单的ip和端口才能正常访问。比如，我在阿里云买了一台云服务器，在服务器上装了tomcat服务，要给外网访问，这时候你要用到iptables加入8080端口，再云控制台添加该端口到安全组。for example 完成上诉操作后你才能在外网访问，比如访问这个地址http://119.23.108.84:8080/ iptables基本使用查看当前iptables表 iptables -nvL --line-numbers 命令里面的n代表numeric数字打印ip和端口，这里的v代表verbose打印详细信息，这里的L代表iptables的全部list打印全部链，line-numbers 加数字前缀。 12345678910111213root@iZwz986xashhbt7wugurgkZ:~# iptables -nvL --line-numbersChain INPUT (policy ACCEPT 0 packets, 0 bytes)num pkts bytes target prot opt in out source destination 1 1640 123K ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:80802 18115 1078K ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:223 1269 95663 ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:804 6500 695K ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:8090Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)num pkts bytes target prot opt in out source destination Chain OUTPUT (policy ACCEPT 80332 packets, 7525K bytes)num pkts bytes target prot opt in out source destination 从上面代码我们看出有端口号8080，22，80，8090都加入了iptables的INPUT ，那么上面的INPUT和FORWADRD和OUTPUT是什么呢。 iptables的INPUT链用来过滤进入的数据，比如我有的手机设置了只能手机尾号是091的人打进来，其他尾号的手机就打不进来了 iptables的OUTPUT链用来过滤出去的数据，比如我的手机在锁屏的紧急模式下只能打紧急电话，其他号码的手机就打不出来了 FORWARD iptables高级使用","categories":[],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://www.lanyimi.com/source/tags/ubuntu/"}]},{"title":"负荷领域的既视感","slug":"负荷领域的既视感","date":"2017-05-07T11:54:48.000Z","updated":"2017-05-07T12:01:02.911Z","comments":true,"path":"2017/05/07/负荷领域的既视感/","link":"","permalink":"http://www.lanyimi.com/2017/05/07/负荷领域的既视感/","excerpt":"","text":"故事发生在TV版命运石之门世界线1年后。因为凤凰院穿越太多世界线了，后遗症是世界线抖动，去到一条新的世界线R，那里只有他一人和他那痛苦的记忆。消失在命运石之门的世界线上证明他在很早前就GG了，在2011年人们没他的记忆。想要救他就要去更早的世界线救他，然后来自未来的的阿万音来到了命运石之门这条世界线上，让助手制造出手机和微波炉组合的时光机，穿越回去救人。回去48小时前不管用，这条线也是没凤凰院的存在，后来，助手要求阿万音来到2005年，那是一条有凤凰院的世界线。最后躲避了车祸，成功救下了凤凰院。然后嘟噜噜那天在扫墓吧，助手亲完凤凰院，凤凰院挟持了嘟噜噜做人质，然后世界线切回到了这是命运石之门的世界线了。 最后：不是我过来了，而是你要回去了。要从这个世界回到命运石之门的世界线，快想起来，当你在无数的世界线举棋不定的时候，一直都是我陪着你，还有真由理 还有桥田 以及菲伊莉斯小姐也是 漆原同学也好 桐生小姐也好 乃至阿万音小姐 大家都没有忘记你，想要自己独力一个人撑起这个世界你想得美别忘了，无论身处哪一条世界线 你都不是一个人；无论你钻到什么地方 我都会把你找出来，我会一直观测着你，就像你一直观测着我一样。 总结：喜欢就追吧，别后悔了。 –The End–","categories":[],"tags":[{"name":"もはや孤独の观测者","slug":"もはや孤独の观测者","permalink":"http://www.lanyimi.com/source/tags/もはや孤独の观测者/"}]},{"title":"搭建jekyll博客","slug":"搭建jekyll博客","date":"2017-04-23T10:47:24.000Z","updated":"2017-04-23T11:07:33.244Z","comments":true,"path":"2017/04/23/搭建jekyll博客/","link":"","permalink":"http://www.lanyimi.com/2017/04/23/搭建jekyll博客/","excerpt":"","text":"前言主流的个人博客都是用hexo搭建的，一部分人喜欢用jekyll搭建，下面我们来细说一下操作流程 效果今天，我们要做到到这个主题效果http://huangxuan.me/ 下载下载rubygems http://rubyinstaller.org/ 选择2.3.3 released，安装过程中现在加入path。 切换ruby镜像在git bash下 1234$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/$ gem sources -lhttps://gems.ruby-china.org# 确保只有 gems.ruby-china.org 如果遇到SSL问题 将https改为http。 下载bundler1$ gem install bundler 如果遇到使用gem下载遇到ENETRESET 问题，请打开https://github.com/rubygems/rubygems/issues/1214，解决办法关键就是关闭防火墙。 下载jekyll 1$ gem install jekyll 下载jeky-paginate 1$ gem install jekyll-paginate 克隆主题新建jekyll文件夹执行 1$ git clone git@github.com:Huxpro/huxblog-boilerplate.git cd到huxblog-boilerplate 执行jekyll serve 可以在http://localhost:4000看到效果。 总结 jekyll博客没hexo博客方便切换主题。 jeky博客加入不同字体，图片，打破你的审美疲劳。","categories":[],"tags":[]},{"title":"AndroidIM融云接入","slug":"AndroidIM融云接入","date":"2017-04-21T08:37:09.000Z","updated":"2017-04-21T09:12:18.727Z","comments":true,"path":"2017/04/21/AndroidIM融云接入/","link":"","permalink":"http://www.lanyimi.com/2017/04/21/AndroidIM融云接入/","excerpt":"","text":"融云篇融云官网地址http://www.rongcloud.cn/docs/android.html 我们一般是接入IMkit，包含界面的sdk。 首先我们需要现在IMKit IMLib（发送文本模块）CallKit CallLib（语音视频模块） LocationLib（地理位置模块） PushLib（推送模块） RedPacket（红包模块） 首先你要去创建一个新的as项目，然后以module的形式导入IMKit IMLib CallKit CallLib RedPacket ，然后把Push的so文件加入jniLibs ，而Jar文件加入libs。 还要把executable的推送保活so文件加入到assets。因为使用的语音报，只能使用armeabi-v7a 和x86的so文件。在app/build.gradle/defaultConfig域内，加入 12345defaultConfig&#123; ndk&#123; abiFilters \"armeabi-v7a\",\"x86\" &#125;&#125; 把官网控制台的app-key 加入到IMLib 模块的Androidminifest.xml内对应的meta标签的RONG_CLOUD_APP_KEY内。还要自己申请高德地图的appkey放在自己app的module里面。 初始化自定义Applicaiton ，并且在Androidmanifest声明。 12345public class App extends Application public void onCreate()&#123; super.onCreate(); RongIM.init(this); &#125; 获取token这里的token是融云sdk的token代表一个用户有效登陆状态，流程是客户端请求服务器，服务器用userid，name和头像地址去请求融云sdk服务器，返回token。 ##连接融云服务器 一般在登录界面 客户端拿到token，调用RongIM.connect(token,ConnectCallback) 在回调成功的方法里面 跳转到融云的聊天列表界面。","categories":[],"tags":[]},{"title":"android面试题","slug":"android面试题","date":"2017-04-20T01:38:32.000Z","updated":"2017-04-22T03:39:04.399Z","comments":true,"path":"2017/04/20/android面试题/","link":"","permalink":"http://www.lanyimi.com/2017/04/20/android面试题/","excerpt":"","text":"1. Activity和fragment的生命周期 Activity从onCreate→onStart→onResume→onPause→onStop→onDestroy，其中oncreate初始化加载布局资源，onStart布局可见但是还在后台不可交互 onResume布局可见在前台可以交互。onPause正在停止当前activity，onStop表示activity即将停止，做一些回收资源操作，onDestroy销毁activity最终的资源释放。总结：onStart和onPause可见不可见，onResume和onStop可不可以交互 Fragment从onAttach→onCreate→onCreateView→onStart→onResume→onPause→onStop→onDestroyView→onDestroy-onDetach ​ 2. Layout_gravity和gravity的区别。比如设置android:layout_gravity=”right”的button会显示在父view的最右边。所以layout_gravity是设置当前view在父view的位置。 比如设置了android:gravity=”left”的LinearLayout会让里面的子View最显示在最左边。所以gravity是设置当前view里面的子view的位置。 3. 当一个activity跳转到另一个activity的生命周期我们分别用AB代替两个activity onPause(A)→onCreate(B)→onStart(B)→onResume(B)→onStop(A) 4.简单介绍Handler Message MessageQueue Looper当Handler调用sendMessage方法会先把调用MessageQueue.enqeueMessage把Message加到消息队列，然后Looper开启循环不断遍历消息队列，调用MessageQueue.next获取message，然后调用目标Handler的dispatchMessage，判断Message有没有Callback即有没有Runnable对象，再判断Handler有没有callback，如果都没最后输出到Handler的handleMessage方法来处理消息。 5. 内存溢出和内存泄露oom又叫out of memory 就是内存溢出。就是对象需求的内存大于jvm可用内存，避免oom要 减小对象内存的使用1）使用更加轻量的数据结构，使用ArrayMap/SparseArray代替HashMap 2）避免使用Enum 3）减小bitmap对象的内存占用 使用insampleSize缩放比例，设置decodeFormat，解码格式 4）使用更小的图片，用tinypng压缩图片 内存对象的重复使用。使用对象池1）StringBuilder减少String对象创建 2）避免在onDraw创建对象，因为onDraw会频繁调用，频繁gc，从而造成内存抖动。 3）复用系统提供的资源，比如字符串 颜色 图片 动画 样式 和布局 4）在listview或者gridview对convertView的复用 5）bitmap对象的复用在api11-18使用inbitmap，确定具有相同的解码模式，第二张图片会使用第一张照片已存在的位置 避免内存泄露1）注意Activity的泄漏，一般是内部类引用导致activity泄露比如handler 2）Activity Context被传到其他实例中，这可能导致自身引用发生泄漏 3）考虑使用Application Context 而不是Activity Context当然dialog就必须是activity的content 4）注意临时的bitmap对象的回收 调用bitmap.recycle() 5） 监听器的注销要手动unregister 比如realm的list监听器 6）注意缓存容器中的对象泄漏比如2.3版本的drawable会对view强引用， 7）注意webview的泄露 8）还有Cursor游标的关闭。 6. Jvm的堆栈方法区堆区存放所有的对象，只有一个，每个对象都包含一个与之对应的class信息class的目的是得到操作指令，但是不包括基本类型和对象引用，new一个类就是对象引用。只存放对象本身。 栈区 每个线程都有一个栈区，用来存放对象的引用和基本类型，（怎么区分对象和对象的应用呢 举个例子 Person person=new Person(); =左边是对象的引用，=右边是对象），其他栈不能访问另外一个栈的内容 方法区，就是静态变量static修饰的变量，常量。","categories":[],"tags":[]},{"title":"设计模式SOLID五大原则","slug":"solid","date":"2017-03-20T03:08:44.000Z","updated":"2017-03-20T07:38:29.524Z","comments":true,"path":"2017/03/20/solid/","link":"","permalink":"http://www.lanyimi.com/2017/03/20/solid/","excerpt":"","text":"设计模式SOLID五大原则SOLID每一个字母都代表这一种编程原则，其中 S代表着单一职责原则 O代表着开闭原则 L代表着里氏替换原则 I代表着接口隔离原则 D代表着依赖倒置原则 单一职责原则单一职责原则就是造成一个类改变的原因一个只有一个。再比如手机的电池是一个类，电池只为手机提供电源的职责。 在Android开发中，adapter类职责只负责视图的显示，这时候你会说adapter里面还有很多方法比如创建视图，显示视图，提供视图数量等。但是根据Martin的话来说变化的指针只在变化真正发生时起作用，如果没有任何征兆，应用单一职责原则或者其他原则是不明智的。就是说adapter创建和显示视图是这个类的职责，而不应该包括视图显示内容的计算逻辑，我只要知道结果就行了。下面看例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//UserOrder.javapublic class UserOrder &#123; private double createTime; public double getCreateTime() &#123; return createTime; &#125; public void setCreateTime(double createTime) &#123; this.createTime = createTime; &#125; &#125;//UserOrderAdapter.javapublic class UserOrderAdapter extends RecyclerView.Adapter&lt;UserOrderAdapter.UserOrderHolder&gt; &#123; List&lt;UserOrder&gt; mList; public UserOrderAdapter(List&lt;UserOrder&gt; list) &#123; this.mList = list; &#125; @Override public UserOrderHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.user_order_rv_item, parent, false); return new UserOrderHolder(view); &#125; @Override public void onBindViewHolder(final UserOrderHolder holder, int position) &#123; holder.mPayBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; UserOrder userOrder=mList.get(position); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); holder.mCreatetime.setText(sdf.format(userOrder.getCreateTime())); &#125; &#125;); &#125; @Override public int getItemCount() &#123; return mList.size(); &#125; public class UserOrderHolder extends RecyclerView.ViewHolder &#123; TextView mCreatetime; public UserOrderHolder(View itemView) &#123; super(itemView); mCreatetime = (TextView) itemView.findViewById(R.id.user_order_createtime); &#125; &#125;&#125; ↑这里的onBindViewHolder处理了视图的逻辑，应该把时间格式化的操作放在UserOrder类中。如下 123456789101112131415161718192021222324//UserOrder.javapublic class UserOrder &#123; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); private double createTime; public String getCreateTime() &#123; return sdf.format(createTime); &#125; public void setCreateTime(double createTime) &#123; this.createTime = createTime; &#125;&#125;//UserOrderAdapter.java @Override public void onBindViewHolder(final UserOrderHolder holder, int position) &#123; holder.mPayBtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; UserOrder userOrder=mList.get(position); holder.mCreatetime.setText(userOrder.getCreateTime());//格式化时间的逻辑放在UserOrder类中 &#125; &#125;); &#125; 总结：一个类只包含一个职责，其他的逻辑放在对应的类上处理。 开闭原则开闭原则就是在每次有新需求都不能在原来的代码中做修改。你可以一开始的时候就用多态和接口来实现架构，让你的代码更容易扩展，而不是修改。 比如你要计算一个三角形的面积 1234567891011121314151617181920//Triangle.javapublic class Triangle&#123; private double width; private double height; private double getArea()&#123; return width*height/2; &#125; //setter&amp;getter&#125;//AreaManagerpublic class AreaManager&#123; private double calculateArea(ArrayList&lt;Triangle&gt; triangles)&#123; double area=0; for(Triangle triangle:triagnles) area+=triangle.getArea(); return area; &#125; &#125; 一开始代码是这样子设计的，但是后续要继续加上圆形，矩形的面积，就要在AreaManager类里面加上计算圆形，矩形的面积方法，不符合我们的开闭原则。所以要写一个shape接口，让三角形矩形都实现这个接口，在calculateArea方法里面传入ArrayList。不管以后要计算什么边形的面积只要实现shape接口即可。 123456789101112131415161718192021222324public interface Shape&#123; double getArea();&#125;public class Circle implements Shape&#123; public static final double pi=3.14; double radius; public double getArea()&#123; return radius*radius*pi; &#125; //setter&amp;getter&#125;public class AreaManager&#123; public double calculateArea(ArrayList&lt;Shape&gt; shapes)&#123; double area=0; for(Shape shape:shapes)&#123; area+=shape.getArea(); &#125; return area; &#125; &#125; 总结：在写计算方法时，考虑到以后有多个方案要怎么设计。通常是多个方案都实现了一个接口，接口方法就是该方案的逻辑。然后在方法被调用时传入接口类作为参数，调用接口方法。 里氏替换原则里氏替换原则就是用接口类或者父类来替代子类，而不改变程序的正确性。 举个例子，下面adapter的构造函数就用了List类型的参数来替换ArrayList类型。 12345678910111213//MainActivity.javaList&lt;String&gt; mList=new ArrayList&lt;&gt;();mList.add(\"str\");UserOrderAdapter adapter=new UserOrderAdapter(mList);//UserOrderAdapter.javapublic class UserOrderAapter extends RecyclerView.Adapter&lt;UserorderHolder&gt;&#123; List&lt;String&gt; list; public UserOrderAdapter(List&lt;String&gt; list)&#123; this.list=list; &#125; &#125; 下面例子用了一个Arraylist的变量作为返回值。 123456public List&lt;String&gt; getList(String[] str)&#123; ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;(); for(String s:str) list.add(s); return list;&#125; 总结，这个原则相当简单你应该相当熟悉或者你每天都在用了。 接口隔离原则接口隔离原则有点像单一职责原则，不过目标是接口类应该只有一种职责。 比如自定义一个View需要加上一个点击事件， 123public interface onClickListener&#123; void onClick(View v);&#125; 然后，你又有需求要加上一个长按事件和一个触摸事件， 12345public interface onClickListener&#123; void onClick(View v); void onLongClick(View v); void onTouch(View v,MotionEvent ev);&#125; 在设置监听这个接口时：你必须重写这三个方法，可能你用不着后面两个方法。 1234567891011new CustomeView.setOnClick(new OnClickListener&#123; public void onClick(View v)&#123; &#125; public void onLongClick(View v)&#123; &#125; public void onTouch(View v,MotionEvent ev)&#123; &#125;&#125;); 这个违背了接口隔离原则，一个实现接口的类应该依赖他最小的接口。 所以我们的onClickListener只要写一个onClick方法就行了。其他的方法另外创建接口来写。比如OnTouchListener。 总结：我们写一个接口类里面的方法应该是同一个职责的，不同职责的接口方法创建新的接口类来实现。 依赖倒置原则依赖倒置就是依赖抽象，而不依赖具体的实例。 就是在项目中我们的架构分为三层，安卓ui→业务逻辑→数据层，业务逻辑具体是判断写入或者获取数据是否符合条件 比如我们现在要做网络可用时将一个字符串写入数据库的操作，这样子activity就持有netmanager和dbmanager的具体实例子，不符合我们的依赖倒置原则。如下： 1234567891011121314151617//MainActivity.javaprotected void onCreate(bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); NetWorkManager netManager=//... DbManager dbManager if(netManager.isNetWorkConnected)&#123; dbManager.insert(); &#125;&#125;//NetWorkManager.javapublic boolean isNetWorkConnected()&#123; &#125;//DbManager.javapublic void insert()&#123;&#125; 所以我们要做出如下修改： 1234567891011121314151617181920212223242526272829303132333435363738394041//MainActivity.javaIDbManager IdbManager;protected void onCreate(bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); IdbManager=new DBManager(this);//实例化BDmanager IdbManager.insert(); &#125;//IDbManager.javapublic interface IDbManager&#123; public void insert();&#125;//DbManager.javapublic class DbManager&#123; INetManager netManager; public void setNetManager(INetManager netManager)&#123; this.netManager=netManager; &#125; public void insert()&#123; if(netManager.isNetworkConnected())&#123; //do &#125; &#125; &#125;//INetManager.javapublic interface INetManager&#123; boolean isNetworkConnected();&#125;//NetManager.javapublic class NetManager&#123; public boolean isNetworkConnected()&#123; //do &#125;&#125; 这样子就可以让activity直接依赖IDbManager的抽象类。 总结：通常我们为了更简单实例化抽象类，我们推荐使用dagger2。","categories":[],"tags":[{"name":"solid","slug":"solid","permalink":"http://www.lanyimi.com/source/tags/solid/"}]},{"title":"EventBus3.0源码分析","slug":"EventBus3-0源码分析","date":"2017-03-13T03:01:06.000Z","updated":"2017-03-20T07:37:16.834Z","comments":true,"path":"2017/03/13/EventBus3-0源码分析/","link":"","permalink":"http://www.lanyimi.com/2017/03/13/EventBus3-0源码分析/","excerpt":"","text":"EventBus3.0源码分析从3.0开始用了更多注解事件的订阅方法来代替之前固定onEvent开头的方法。现在你可以是容易方法加上@Subscribe的注解。 更多的eventbus使用方法请看http://www.jianshu.com/p/c47e0900399e EventBus.java EventBus类的创建使用了常见的单例模式，如下： 1234567891011static volatile EventBus defaultInstance; //volatile 修饰的变量防止被编译器优化，导致执行顺序变化public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance; &#125; 使用了建造者模式给变量赋值。先在EventBus的构造方法创建EventBusBuilder ，再重载过的EventBus方法传入builder来配置一些变量（比如一些exception）。如下： 123456789101112131415161718 EventBus(EventBusBuilder builder) &#123; subscriptionsByEventType = new HashMap&lt;&gt;(); typesBySubscriber = new HashMap&lt;&gt;(); stickyEvents = new ConcurrentHashMap&lt;&gt;(); mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10); backgroundPoster = new BackgroundPoster(this); asyncPoster = new AsyncPoster(this); indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0; subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes, builder.strictMethodVerification, builder.ignoreGeneratedIndex); logSubscriberExceptions = builder.logSubscriberExceptions; logNoSubscriberMessages = builder.logNoSubscriberMessages; sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent; sendNoSubscriberEvent = builder.sendNoSubscriberEvent; throwSubscriberException = builder.throwSubscriberException; eventInheritance = builder.eventInheritance; executorService = builder.executorService;&#125; 在register中，获取订阅者的类subscriberClass通常是activity和fragment。然后通过subscribeerMethodFinder获取订阅者上订阅方法返回一个list集合。其中subscriberMethod就是写在activity上拿来接受消息的方法的对象，里面的变量包括Method就可以知道方法名；eventType可以知道是ativity还是fragment；threadMode是哪个线程；sticky是否粘性事件；priority优先级系数多少。如下： 123456789public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"Realm-in-android-1","slug":"Realm-in-android-1","date":"2017-02-23T07:19:00.000Z","updated":"2017-02-24T06:48:54.901Z","comments":true,"path":"2017/02/23/Realm-in-android-1/","link":"","permalink":"http://www.lanyimi.com/2017/02/23/Realm-in-android-1/","excerpt":"","text":"Realm介绍 Realm官网链接https://realm.io/ 开源地址https://github.com/realm/realm-java 官方使用文档https://realm.io/docs/java/latest/ Realm是一个开源的ORM概念的（对象关系映射）移动数据库，可以在Android ，ios ，java各个平台上使用，性能秒杀sqlite等数据库比如（greendao）。 快速入门只需两步 在项目的build.gradle中dependencies输入classpath “io.realm:realm-gradle-plugin:2.3.1”，这里要双引号。这里要双引号。这里要双引号。 1234567891011121314buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.2.3' classpath \"io.realm:realm-gradle-plugin:2.3.1\" // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125; 在app的bulid.gradle输入apply plugin: ‘realm-android’ 1apply plugin: 'realm-android' ★以上操作完成了realm在as的配置了。 Realm的模型自定义类要继承RealmObject，注意这里必须要有一个无参数的构造方法。 1234567891011121314151617181920212223242526272829public class Dog extends RealmObject &#123; private String name; private int age; public Dog() &#123; &#125; public Dog(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 如果类A中包含着其他类的集合这时候要用到ResultList，比如 123456public class Person extends RealmObject &#123; @PrimaryKey private long id; private String name; private RealmList&lt;Dog&gt; mDogRealmList; &#125; 如果你的自定义类已经继承了其他父类，你也可以实现RealmModel来建造realm对象模型。 1234567@RealmClasspublic class User implements RealmModel &#123; private String name; private int id; //...&#125; Realm注解说明@RealmClass 当实现RealmModel接口的类要加上这个注解。 @Required 修饰不能为空的成员变量 @Ignore 修饰不写入数据库的变量 @PrimaryKey 设置该成员变量为类的主键 @Index 加快查询速度，不过会让插入数据时变慢 Realm初始化在自定义Applciation中Realm.init(this); 获取Realm实例 1realm = Realm.getDefaultInstance(); 这是获取默认配置的Realm，默认保存在data/data/packageName/files/default.realm 你也可以自定义RealmConfiguration，通常是自定义文件名，加密的key，数据库版本号和是否删除合并前的数据等。Realm实现了closeable接口，所以每次的getInstance，到最后关闭使用后都要调用close方法。比如在activity的ondestroy调用realm.close(); Realm写入Realm是一个MVCC架构，同一线程的读写操作不影响获取数据，但是多线程读取写入操作就要用到事务来确保获取数据一致性和线程安全。的是放在事务transcation里面执行，确保整个事务的操作都被提交或者全部取消操作调用realm.cancelTranscation();，确保数据的一致性。 123456realm = Realm.getDefaultInstance();realm.beginTransaction();Dog d=new Dog(\"a\",1);Dog b=realm.copyToRealm(d);//这里的copyToRealm相当于深拷贝了一个d变量。对原来的d变量没任何影响。b.setName(\"b\");realm.commitTransaction(); //最后往数据库写入一个dog变量b ♥copyToRealm会深拷贝一个变量到数据库包括主键，如果主键重复就会抛出异常，拷贝之后主键不能修改。 当两个线程同时进行写入操作，另外一个会造成主线程阻塞，所以要调用异步事务避免主线程阻塞。 12345678//同步新增数据realm.executeTransaction(new Realm.Transaction() &#123; @Override public void execute(Realm realm) &#123; Dog dog = realm.copyToRealm(new Dog(1, \"2\", 3)); dog.setName(\"pp\"); &#125;&#125;); 1234567891011121314151617//异步修改 查询realm.executeTransactionAsync(new Realm.Transaction() &#123; @Override public void execute(Realm realm) &#123; Dog dog = realm.copyToRealm(dogOne); dog.setName(\"apple\"); &#125;&#125;, new Realm.Transaction.OnSuccess() &#123; @Override public void onSuccess() &#123; RealmResults&lt;Dog&gt; list = realm.where(Dog.class).findAll(); for (int i = 0; i &lt; list.size(); i++) &#123; Log.i(TAG, \"onSuccess: \" + list.toString()); &#125; &#125;&#125;); realm的主键，在oncreate方法加入设置主键的RealmObject方法，下次调用oncreate没有判断主键是否exist就加入数据库就会报错。而在oncreate方法没加入没设置主键的realmobject类 ，下次调用oncreate方法就会在自启动数据库文件追加。 Realm 查询查询都是返回一个RealmResults对象支持以下查询条件。 between()，greaterThan()， lessThan()， greaterThanOrEqualTo() 和lessThanOrEqualTo(); equalTo()和notEqualTo() contains()，beginsWith()和endsWith() isNull()和isNotNull() isEmpty()和isNotEmpty() 1234RealmResults&lt;Dog&gt; list=realm.where(Dog.class).lessThan(\"age\",1).findAll();for (int i = 0; i &lt; list.size(); i++) &#123; Log.i(TAG, \"execute: \"+list.get(i).getName());&#125; Realm修改修改操作要在一个事务里面完成。 12345678910111213141516dog = new Dog(1, \"a\", 1); realm.executeTransaction(new Realm.Transaction() &#123; @Override public void execute(Realm realm) &#123; dog = realm.copyToRealm(dog); dog.setAge(2); dog.setName(\"kiki\"); RealmResults&lt;Dog&gt; list = realm.where(Dog.class).equalTo(\"id\", 1).findAll(); list.get(0).setName(\"ab\"); &#125; &#125;); RealmResult的changeListener监听RealmResult内容变化。 12345678910111213141516171819202122232425RealmResults&lt;Dog&gt; list = realm.where(Dog.class).lessThan(\"id\", 3).findAll();realm.executeTransaction(new Realm.Transaction() &#123; @Override public void execute(Realm realm) &#123; Dog dog = realm.createObject(Dog.class); dog.setId(2); dog.setName(\"aaaa\"); dog.setAge(3); &#125;&#125;);list.addChangeListener(new RealmChangeListener&lt;RealmResults&lt;Dog&gt;&gt;() &#123; @Override public void onChange(RealmResults&lt;Dog&gt; element) &#123; Log.i(TAG, \"onChange: \" + element.toString()); &#125;&#125;);//最后需要在activity或者fragment的生命周期比如ondestory调用list.removeChangeListeners();//删除全部的listenerlist。removeChangeListener(callback);//删除一个callback Realm的删除继续上面的例子查询id小于3的realmresult集合 12345678910list.addChangeListener(new RealmChangeListener&lt;RealmResults&lt;Dog&gt;&gt;() &#123; @Override public void onChange(RealmResults&lt;Dog&gt; element) &#123; element.deleteFirstFromRealm();//删除第一条数据 element.deleteAllFromRealm();//删除全部数据 element.deleteFromRealm(0);//删除指定数据 element.deleteLastFromRealm();//删除最后一条数据 element.get(1).deleteFromRealm();//删除指定obejct &#125;&#125;); Realm添加一个json字符串12345678910realm.executeTransaction(new Realm.Transaction() &#123; @Override public void execute(Realm realm) &#123; realm.createObjectFromJson(Dog.class,\"&#123;\\n\" + \" \\\"id\\\": 1,\\n\" + \" \\\"name\\\": \\\"bili\\\",\\n\" + \" \\\"age\\\": 12\\n\" + \"&#125;\"); &#125;&#125;); copyFromRealm，copyToRealm和createObject区别 copyFromRealm传入一个RealmObject 拷贝realm数据库中的一个变量并拷贝他的所有属性。 copyToRealm 传入一个Obeject 拷贝这个Object的所有属性到realm数据库中 createObject 传入一个class 并且赋值他的成员变量为默认值null 或者需要后期赋值使用 RealmResult 使用12345RealmResults&lt;Dog&gt; list = realm.where(Dog.class).findAll(); list.sum(\"age\"); list.max(\"age\"); list.min(\"age\"); list.average(\"age\"); 比如获取dog类的所有对象，求age的总和，最大值，最小值，平均值 DynamicRealmDynamicRealm是Realm的变种类，可以操作没继承RealmObject的类，操作类，当然是以字符串的形式操作，而不是RealmObject，他的默认配置少了schema版本号，migration合并信息的检查。 123456789DynamicRealm dynamicRealm = DynamicRealm.getInstance(new RealmConfiguration.Builder().build()); dynamicRealm.executeTransaction(new DynamicRealm.Transaction() &#123; @Override public void execute(DynamicRealm realm) &#123; DynamicRealmObject person = realm.createObject(\"Person\",1); person.setString(\"name\", \"kik\"); &#125; &#125;); Realm的closeRealm实现了closeable接口，所以每次的getInstance，到最后关闭使用后都要调用close方法。比如在activity的ondestroy调用realm.close(); 比如在子线程getIntstance一次，需要在子线程结束前调用一次close(); 123456789101112131415class MyRunnable implements Runnable&#123; @Override public void run() &#123; try &#123; Realm realm=Realm.getDefaultInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; realm.close(); &#125; &#125;&#125; Realm 版本迁移如果realm版本是1，现在要升级realm版本是2并且数据解构改变了比如新增了一个RealmObejct的成员变量，如果default.realm存在旧数据，会升级失败。需要要设置migration合并规则。 要自定义一个RealmConfiguration变量 ，重写migrate方法判断oldVersion是上一个版本号，要做什么需求。 12345678910//你还可以做以下操作addField(\"key\",long.class);//加一个成员变量keyremoveField(\"key\");//去掉一个成员变量keyaddRealmListField(\"dogs\",schema.get(\"Dog\"));//加上Realmlist变量dogsaddRealmObjectField(\"dog\",schema.get(\"Dog\"));//加上realmobject变量dogtransform(new RealmObjectSchema.Function()&#123; public void apply(DynamicRealmObject obj)&#123; obj.set(\"fullname\",obj.getString(\"firstName\")+\" \"+obj.getString(\"lastName\")) &#125;&#125;);//把firstname lastname赋值给fullname 比如版本升级加上key 1234567891011121314151617181920212223242526272829303132333435363738 RealmMigration mRealmMigration=new RealmMigration() &#123; @Override public void migrate(DynamicRealm realm, long oldVersion, long newVersion) &#123; RealmSchema schema=realm.getSchema();/* //version 0 class Dog private long id; private String name; private int age; //version 1 class Dog private long key; private long id; private String name; private int age; */ //version 0 to version 1 if(oldVersion==1)&#123; schema.get(\"Dog\") .addField(\"key\",long.class); /* .addRealmObjectField(\"dogs\",schema.get(\"Dog\")) .addRealmObjectField(\"dog\",schema.get(\"Dog\"));*/ oldVersion++; &#125; &#125; &#125;; //最后 realm = Realm.getInstance(PPApplicaion.mMigrationConfiguration); 总结 Realm很多种情况修改数据要配合事务使用。 Realm以一个RealmObject作为一个表的功能。 realm的getInstance和close要结对使用 需要注意RealmResult移除listener","categories":[],"tags":[{"name":"Realm","slug":"Realm","permalink":"http://www.lanyimi.com/source/tags/Realm/"}]},{"title":"java线程中的Runnable，Callable，Future，FutureTask","slug":"java线程中的Runnable，Callable，Future，FutureTask","date":"2017-02-15T03:20:56.000Z","updated":"2017-02-15T08:42:31.659Z","comments":true,"path":"2017/02/15/java线程中的Runnable，Callable，Future，FutureTask/","link":"","permalink":"http://www.lanyimi.com/2017/02/15/java线程中的Runnable，Callable，Future，FutureTask/","excerpt":"","text":"前言，在java线程中最常见的是Thread 和Runnable，很少见到或者用到callable等类。但是，你接触过android源码就会经常看到这些类，比如AsyncTask的源码在execute方法源码可以看到了这些类。在面试时也有可能会问到两者的区别，所以现在容许鄙人来介绍一下java中这些类的用法。 RunnableRunnable一个接口类，包括一个run的接口方法：通常我们会自定义一个类去实现Runnable，这时候还可以实现其他接口方法，如果类要是继承Thread就不能再继承其他类了。 123public interface Runnable&#123; public abstract void run();&#125; Runnable 通常配合Thread使用，在run方法里面写耗时的操作： 12345new Thread(new Runnable()&#123; public void run()&#123; // &#125;&#125;).start(); CallableCallable是一个泛型接口，要比Runnable强些 ，因为接口方法call有返回值，并且返回值是传入的泛型类型，还能call的过程中抛出异常。 123public interface Callable&lt;V&gt;&#123; V call() throws Exception;&#125; 示例要配合Future或者FutureTask来执行。 FutureFuture是一个泛型接口类，是Runnable和Callable的调度容器，就是对Runnable和Callable的结果进行操作，比如： isCancelled()取消操作，call方法任务完成前取消，返回true。 isDone()判断是否操作完成，是则返回true。 get()获取操作结果，会导致程序阻塞，必须等到子线程结束才会得到返回值。 get(long timeout TimeUnit unit)在某时间后获取操作结果，如果在规定时间内获取不到返回值将会抛出超时异常） 1234567public interface Future&lt;V&gt;&#123; boolean isCancelled(); boolean isDone(); V get() throws InterputeredException,ExecutionExeception; V get(long timeout ,TimeUnit unit)throws InterputeredException,ExecutionExeception,TimeoutExeception; &#125; 比如 123456789ExecutorService threadPool=Executors.newSingleThreadExecutor();Future future=threadPool.submit(new Callable&lt;String&gt;()&#123; public String call()throws Exception&#123; return \"result\"; &#125; &#125;);Futurn.get();//返回操作结果 FutureTaskFutureTask类同时实现了Runnable和Future 两个接口，具有了两个接口的属性。 1234567891011121314151617public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;&#123; public FutureTask(Callable&lt;V&gt; callable)&#123; this.callable=callable; ... &#125; public FutureTask(Runnable runnable,V result)&#123; this.callable=Executors.callable(runnable,result); ... &#125; boolean isCancelled(); boolean isDone(); V get() throws InterputeredException,ExecutionExeception; V get(long timeout ,TimeUnit unit)throws InterputeredException,ExecutionExeception,TimeoutExeception;&#125;public interface RunnableFuture&lt;V&gt; implements Runnable,Callable&lt;V&gt;&#123; void run();&#125; 这里的FutureTask间接实现了两个接口，在FutureTask的构造方法传入Callable或者是Runnable都会转为callable，runnable通过runnableadapter转为callable。同时FutureTask还具备Future的所有方法。 举个例子 123456789Callable&lt;Integer&gt; callable=new Callable&lt;Integer&gt;()&#123; public Ingeter call() throws Exception&#123; return 100; &#125;&#125;;FutureTask&lt;Integer&gt; task=new FutureTask&lt;Integer&gt;(callable);new Thread(task).start();task.get();//当然要先启动线程才能得到结果； 这里的callable当成runnable用了。 总结 Callable比Runnable高级能返回结果值和抛出异常。 可以有上述例子看到Callable来产生结果，Futuretask来获取结果。 在获取结果期间还可以控制是否取消thread 判断thread是否完成。 ​","categories":[],"tags":[{"name":"Java线程","slug":"Java线程","permalink":"http://www.lanyimi.com/source/tags/Java线程/"}]},{"title":"AsyncTask-Analyze","slug":"AsyncTask-Analyze","date":"2017-02-13T09:05:04.000Z","updated":"2017-02-13T10:02:35.142Z","comments":true,"path":"2017/02/13/AsyncTask-Analyze/","link":"","permalink":"http://www.lanyimi.com/2017/02/13/AsyncTask-Analyze/","excerpt":"","text":"我们在初学Android都用过AsyncTask 一个很方便用来请求网络改变UI控件的类。面试官不多不少也会问到AsyncTask的内容，下面来分析一下这个类内部的逻辑。 AsyncTask说明AsyncTask内部封装了Handler和Thread分别原来改变ui线程和在子线程做耗时操作。同时AsyncTask是一个抽象的泛型类 1public abstract class AsyncTask&lt;Params,Progress,Result&gt;&#123;&#125; Params代表参数类型（doInBackground的参数）通常是请求的url Progress代表进度类型（onProgressUpdate的参数）通常是Integer Result代表结果返回类型（onPostExecute的参数），如果asynctask不需要传递参数就用Void来代替上述三个参数类型 AsyncTask 4个核心方法 onPreExecute() 异步开始前会执行该方法，用于显示dialog doInBackground(Params… params) 在线程池执行的异步任务，在此方法内调用publishProgress 传入int进度值来更新进度，返回结果给onPostExecute，这里的省略号是可以传入多个相同类型的参数。 onPorgressUpdate(Progress… progress) 此方法在主线程执行，当任务发生进度改变就会调用此方法，比如显示下载进度 onPostExecute(Result… result) 主线程执行，但异步方法执行完就会调用的方法。传入参数为doInBackground的返回值. ps: 当doInBackground的线程被取消就会回调给onCancelled这个方法，此方法被调用onPostExecute就不会调用了。 总结： asynctask对象要在主线程创建，并调用execute方法 不能直接调用doinbackground方法 一个asynctask对象只执行一次 3.0之前asynctask用并行线程池执行，3.0后asynctask改用串行线程池，当然你可以通过asynctask.executeOnExecutor来并行执行任务 源码入口executeAsyncTask开始执行的方法是在new AsyncTask().execute(url1)，execute又调用了executeOnExetutor方法 传入一个串行的线程池SDefaultExecutor和url参数。以下代码： 1234@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125; 上面的sDefaultExecute就是new一个SerialExecute类 123public static final Executor SERIAL_EXECUTOR = new SerialExecutor();private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR; 进入SerialExecutor类，我们看到这个类有个mTask 里面的Runnable会排队执行。并且判断执行完开始执行下一个任务。 12345678910111213141516171819202122232425private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125; 接来下，回到executeOnExetutor 这个方法里面 我们可以看到一个mStatus来记录当前任务的状态，期间不断改变状态。 每个AsyncTask最先执行onPreExecute方法，然后线程池exec.execute(mFuture);开始执行。这里的mFuture就是一个Runnable 123456789101112131415161718192021222324@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(\"Cannot execute task:\" + \" the task is already running.\"); case FINISHED: throw new IllegalStateException(\"Cannot execute task:\" + \" the task has already been executed \" + \"(a task can be executed only once)\"); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this;&#125; 接着将mFuture传入SerialExecutor的execute方法执行，将之前的mFuture对象插入队列mTask里面,判断当前有没有任务在进行，没活动就调用schedulNext方法执行下一个asynctask任务。 Asynctask里面有2个线程池(一个用于排队的serialexecutor和用于真正执行任务的THREAD_POOL_EXECUTOR )和(负责线程调度的)internalHandler 然后在Asynctask的构造方法 mWork会调用call方法将mTaskInvoked设置为true，再调用doinbackground 得到返回值再调用onpostexecute方法， 在postResult方法里面会发送message到sHandle来执行finish task还是更新进度条，这里的finish有2种情况分别是调用onCancelled 和onPostexecute. 12345678910111213141516171819public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result); &#125; return result; &#125; &#125;;","categories":[],"tags":[{"name":"AsyncTask","slug":"AsyncTask","permalink":"http://www.lanyimi.com/source/tags/AsyncTask/"}]},{"title":"IPC机制基础","slug":"IPC机制基础","date":"2017-01-19T08:54:08.000Z","updated":"2017-02-13T10:02:04.071Z","comments":true,"path":"2017/01/19/IPC机制基础/","link":"","permalink":"http://www.lanyimi.com/2017/01/19/IPC机制基础/","excerpt":"","text":"IPC基础分享这一章主要讲述多进程的作用，序列化和反序列化，Serializable和Parcelable ​ IPC叫进程间通信，指的是A进程和B进程交换信息。通常一个android应用是一个进程，一个进程有一个主线程和多个子线程组成，在A进程activity定义变量private static int i=1;并且让i+1,输出2，到了B进程activity，获取到的i的值还是1，这是因为Android多进程间不能共享内存。启动多进程期间，会再次启动Application的生命周期，比如application类的oncreate等方法又执行了一次。不过，在android有以下方法进行进程间交换数据 bundle（用bundle和intent在两个进程传递数据） 操作文件（读写操作同一个文件） AIDL（基于binder的通信方式，用aidl文件更加方便） Messenger（封装后的aidl，只需用Messenger.send(message);即可发送信息） ContentProvider（读写数据库） Socket（启动本地的套接字来通信） 多进程的作用 把应用某个单独的功能，单独放在一个进程中。 能给应用获取多份内存空间 开启多进程在AndroidManifest.xml文件给对应的activity或者service设置以下属性，其中值为:remote的进程不能共享进程资源，其他两个值能共享，前提条件是在manifest标签配置相同的sharedUserId比如（android:sharedUserId=”com.ppjun.sharedUserId”），还要让两个应用配置相同的签名。 123&lt;android:process=\":remote\"/&gt; //对应的进程名是包名:remote&lt;android:process=\".remote\"/&gt; //对应的进程名是包名.remote&lt;android:process=\"com.ppjun.remote\"/&gt; //对应的进程名是com.ppjun.remote 序列化和反序列化 序列化就是永久保存对象数据到文件中。 在activity或者service之间将对象序列化对象后通过intent等传递。 在多进程之间也要将对象序列化后才能传递。 序列化是一个将对象变成字节的过程，发序列化是将这些字节重组成一个对象的过程。在Android中提供了Serializable和Parcelable接口序列化对象。 Serializable让类实现Serializable接口，并且指定一个long类型的serialVersionUID=xxxxL;xxxx为你自定义值 12345678910111213141516public class Student implements Serializable &#123;private static int final long serialVersionUID=213213123L private String name; public Student(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 序列化student 1234Student student = new Student(\"jax\");ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(\"aa.txt\").getName()));oos.writeObject(student);oos.close(); 反序列化student 123ObjectInputStream ois=new ObjectInputStream(new FileInputStream(new File(\"aa.txt\")));Student student2= (Student) ois.readObject();ois.close(); 此时的student2已经不是原来的student了，是一个新的Student对象了。当然这里没写serialVersionUID序列化和反序列也能成功运行，系统默认会计算出一个serialVersionUID。 当你要在Student类加入id属性加入，此时系统会计算出新的serialVersionUID，发序列化时，两者serialVersionUID不同，反序列操作时就会报错。所以一定要自定义一个serialVersionUID。 Parcelableandroid api为我们提供的序列化类，也是要类实现Parcelable接口，重写带参数的构造方法，writeToParcel方法，describeContents方法和new CREATOR对象呢重写createFromParcel方法和newArray方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Book implements Parcelable &#123; public static final Creator&lt;Book&gt; CREATOR = new Creator&lt;Book&gt;() &#123; @Override public Book createFromParcel(Parcel source) &#123; return new Book(source); &#125; @Override public Book[] newArray(int size) &#123; return new Book[size]; &#125; &#125;; public int bookId; public String bookName; public Book(int bookId, String bookName) &#123; this.bookId = bookId; this.bookName = bookName; &#125; protected Book(Parcel parcel) &#123; bookId = parcel.readInt(); bookName = parcel.readString(); &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeInt(bookId); dest.writeString(bookName); &#125; @Override public int describeContents() &#123; return 0; &#125; public int getBookId() &#123; return bookId; &#125; public void setBookId(int bookId) &#123; this.bookId = bookId; &#125; public String getBookName() &#123; return bookName; &#125; public void setBookName(String bookName) &#123; this.bookName = bookName; &#125;&#125; 两者比较 Serializable序列化同时产生大量临时变量，导致gc频繁；Serializable要通过io操作获取获取数据，再写入文件。 Parcelable是以binder为信息载体，在内存传递上开销小。在读写数据时，Parcelable直接在内存读写，所以Parcelable性能比Serializable好。 将对象序列化写入文件，序列化对象进行网络传输建议选择Serializable，对象要在activity等组件传递时，建议选择Parcelable。","categories":[],"tags":[{"name":"IPC","slug":"IPC","permalink":"http://www.lanyimi.com/source/tags/IPC/"}]},{"title":"Java硬软弱虚引用，GC回收，内存碎片","slug":"Java硬软弱虚引用，GC回收，内存碎片","date":"2017-01-19T06:07:37.000Z","updated":"2017-02-13T10:01:08.972Z","comments":true,"path":"2017/01/19/Java硬软弱虚引用，GC回收，内存碎片/","link":"","permalink":"http://www.lanyimi.com/2017/01/19/Java硬软弱虚引用，GC回收，内存碎片/","excerpt":"","text":"Java硬软弱虚引用，GC回收，内存碎片GarBageCollection首先说一下java的gc垃圾回收机制，到底什么时候回收，在哪里回收。 经常说java分别在栈区和堆区存储变量等。其实还有 程序计数器它是一个字节码的指示器，告诉当前线程下一步要执行哪一行代码。一个没有OOm的区域 栈区又叫java虚拟机栈区，是每一个方法被执行的时候，创建出一个栈帧用来放的成员变量，操作链表，动态链接，方法出口。很多个栈帧又存储在栈区。 本地方法栈如果说栈区是一个java的本地方法栈，那么本地方法栈就就是c++的native栈区 堆区当类中创建实例变量，就会在堆区中分配内存，堆区又分为新生代，老年代。当新生代没有足够多内存实例对象就是OOM 方法区用来存放被虚拟机加载的类信息，常量，静态变量。 运行时常量池运行时常量池用来存放编译期间的常量 什么时候GC 在类中每当我们实例化一个变量时，都会在新生区申请足够的内存，如果申请的内存不足以实例化对象，这时候就会minor GC 小规模的回收。 在太多的对象在老年代，导致没有足够的内存空间加入对象时，就会full GC，并且直到老年代能放得下更大的对象。 每次minor gc都会检查一下进入老年代的对象和老年代剩余空间，如果不够就会full gc 手动执行System.gc(); 内存碎片内部碎片分配内存到进程A，内存被进程占据了而不被利用，同时系统也无法利用这块内存，直到进程A被终结，释放内存。 外部碎片还没被分配出去的内存太少了不足分配给下一个进程，又或者多个不连续的内存总空间长度能满足新申请的进程，但是由于地址是不连续的内存，无法分配给新进程。 Java硬软弱虚引用硬引用硬引用是我们用得最普遍的方式，就算应用程序内存不足，需要的内存大于可用的内存发生OOM程序崩溃，也不会去回收这个对象。 软引用当内存足够就不会去回收这个对象，当内存不够就会去回收这个对象把引用对象加入SoftReference对象，把引用赋值成null，手动调用System.gc()，加不加入ReferenceQueue队列取决于内存够不够用。回收对象都会进入ReferenceQueue。 123456ReferenceQueue&lt;Object&gt; queue=new ReferenceQueue&lt;Object&gt;();Object object =new Object();SoftReference&lt;Object&gt; softReference=new SoftReference&lt;&gt;(object,queue);obj=null;System.gc();System.out.println(queue.poll());//查看队列元素 弱引用当回收器扫描出弱引用不管内存是否够用，都会回收这个对象。把弱引用对象加入WeakReference对象，把引用赋值成null，手动调用System.gc()，到最后的才会加入ReferenceQueue队列。回收对象都会进入ReferenceQueue。 123456ReferenceQueue&lt;Object&gt; queue=new ReferenceQueue&lt;Object&gt;();Object object =new Object();WeakReference&lt;Object&gt; softReference=new WeakReference&lt;&gt;(object,queue);obj=null;System.gc();System.out.println(queue.poll());//查看队列元素 虚引用当GC发现了虚引用对象把对象加到PhantomReference对象中，最后将虚引用赋值为null，再手动调用System.gc()，到最后的才会加入ReferenceQueue队列。回收对象都会进入ReferenceQueue。 123456ReferenceQueue&lt;Object&gt; queue=new ReferenceQueue&lt;Object&gt;();Object object =new Object();PhantomReference&lt;Object&gt; softReference=new PhantomReference&lt;&gt;(object,queue);obj=null;System.gc();System.out.println(queue.poll());//查看队列元素","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://www.lanyimi.com/source/tags/java/"}]},{"title":"帧动画","slug":"帧动画Animation","date":"2017-01-17T11:36:49.000Z","updated":"2017-01-17T11:57:42.079Z","comments":true,"path":"2017/01/17/帧动画Animation/","link":"","permalink":"http://www.lanyimi.com/2017/01/17/帧动画Animation/","excerpt":"","text":"帧动画下面我们来说什么是帧动画。小时候有一种书的右下角把每一个动作画好，再快速的翻看，就可以看到一连串的动画了，这就是帧动画。帧动画只要几张图片就能加载出动画效果了。其中帧动画是按照一定时间间隔显示一张图片。 在xml设置帧动画具体实现在drawable下（而不是anim下），新建xml文件，用animation-list标签包着多个item标签，设置item标签的drawable和duration值。以imageview为载体可以在xml设置src和在类中用iamgeview.getDrawable获取AnimationDrawable,再调用start方法或者stop方法。 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!--android:oneshot=\"true\"设置为true则播放一次动画，false则一直循环播放--&gt;&lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:oneshot=\"true\"&gt; &lt;item android:drawable=\"@mipmap/ic_launcher\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@mipmap/ic_launcher\" android:duration=\"200\" /&gt;&lt;/animation-list&gt; 调用帧动画写好xml文件我们就可以在类中通过以下方法来调用动画123mImageView.setImageResource(R.drawable.frame);AnimationDrawable drawable = (AnimationDrawable) mImageView.getDrawable();drawable.start();","categories":[],"tags":[{"name":"frameAnimation","slug":"frameAnimation","permalink":"http://www.lanyimi.com/source/tags/frameAnimation/"}]},{"title":"属性动画第一话","slug":"PropertyAnimation","date":"2017-01-17T08:30:29.000Z","updated":"2017-01-18T08:52:07.085Z","comments":true,"path":"2017/01/17/PropertyAnimation/","link":"","permalink":"http://www.lanyimi.com/2017/01/17/PropertyAnimation/","excerpt":"","text":"Android属性动画（第一话）3.0前的帧动画，补间动画Android动画能给界面带来很炫的效果，如果我们要实现这些效果，在android3.0版本前实现动画主要有2种方式，帧动画（frame animation）和补间动画（tweened animation）。 帧动画加载大量图片，对性能有很大要求效率不高，补间动画是对view进行包括缩放，移动，旋转，透明度的绘制。因为补间动画实现不了动画操作后的view的点击等操作，只是简单在操作后的地方显示一个，并不会加上view原来的属性，比如一个button从父容器左上角移动到右下角，他的点击事件还在左上角。 介绍属性动画为了解决上述问题，新推出了View的属性动画，原理是改变view的属性，所以我们可以操作缩放移动透明度旋转后的view，原理是在一段时间内不断设置View.setRotation()，下面我们来介绍一下ValueAnimator。 ValueAnimator123456789101112 //动画是200毫秒内view由0过渡到1ValueAnimator valueAnimator = ValueAnimator.ofFloat(0f, 1f);valueAnimator.setDuration(200);valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; //监听输出动画移动的值 float value = (float) animation.getAnimatedValue(); &#125;&#125;);valueAnimator.start(); 生成ValueAnimator的方法除了ValueAnimator.ofFloat(float);参数要精确到小数点后几位，还有ValueAnimator.ofInt(int);参数是整型比如1，100。 ValueAnimator还有其他属性，比如设置延迟时间ValueAnimator.setStartDelay(200);设置延时200毫秒，还有循环次数ValueAnimator.setRepeatCount(5);动画循环5次，又或者是动画播放模式正常ValueAnimator.RESTART还是反向播放的ValueAnimator.setRepeatMode(ValueAnimator.REVERSE);发向播放动画。 ObjectAnimatorObjectAnimator继承了ValueAnimator,所以ValueAnimator有的方法ObjectAnimator都有。ObjectAnimator是操作具体的控件比如button，imageview的动画，举几个例子： 图片从x轴的-500的位置移动到100的位置1234ObjectAnimator objectAnimator=ObjectAnimator.ofFloat(mImageView,\"translationX\",-500f,100f); objectAnimator.setDuration(500); objectAnimator.start(); 透明度由1变成0再变成1的动画 1234ObjectAnimator objectAnimator=ObjectAnimator.ofFloat(mImageView,\"alpha\",1f,0f,1f); objectAnimator.setDuration(500); objectAnimator.start(); 旋转360度的动画1234ObjectAnimator objectAnimator=ObjectAnimator.ofFloat(mImageView,\"rotation\",0f,360f); objectAnimator.setDuration(500); objectAnimator.start(); y轴上缩放3倍的动画1234ObjectAnimator objectAnimator=ObjectAnimator.ofFloat(mImageView,\"scaleY\",1f,3f); objectAnimator.setDuration(500); objectAnimator.start(); 如果你觉得单单实现一种动画还不够炫，如果你想同时实现多个动画，你要用到动画组合AnimatorSet AnimatorSet把多个ObjectAnimator按顺序连接起来，比如把上面的缩放，移动，设置透明度组合起来 12345678ObjectAnimator scaleYAnimator=ObjectAnimator.ofFloat(mImageView,\"scaleY\",1f,3f);ObjectAnimator translationXAnimator=ObjectAnimator.ofFloat(mImageView,\"translationX\",0f,100f);ObjectAnimator alphaAnimator=ObjectAnimator.ofFloat(mImageView,\"alpha\",1f,0f,1f);AnimatorSet animatorSet=new AnimatorSet();animatorSet.play(scaleYAnimator).with(translationXAnimator).with(alphaAnimator);animatorSet.setDuration(500);animatorSet.start(); 这里Animator.after将其他动画加到这个动画之后，还可以传入动画设置两个动画的间隔，Animator.with两个动画一起播放，Animator.before插入动画放在这个动画之前。 动画监听器1234567891011121314151617181920212223242526ObjectAnimator objectAnimator=ObjectAnimator.ofFloat(mImageView,\"scaleY\",1f,3f);objectAnimator.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; //动画的时候 &#125; @Override public void onAnimationEnd(Animator animation) &#123; //动画结束的时候 &#125; @Override public void onAnimationCancel(Animator animation) &#123; //动画取消时 &#125; @Override public void onAnimationRepeat(Animator animation) &#123; //动画循环时 &#125; &#125;); objectAnimator.setDuration(500); objectAnimator.start(); 你也可以单独实现一个监听方法，这里的AnimatorListener改为AnimatorListenerAdapter就可以了1234567objectAnimator.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; super.onAnimationEnd(animation); &#125; &#125;); 设置XML动画如果有多个界面的控件要实现相同的动画效果，我们可以通过xml更加有效率来设置动画。在res/animator文件夹下新建animator.xml(注意，res/anim这个文件夹是补间动画，res/drawable放帧动画)根标签是一个 代表一个ObjectAnimator，标签内有duration动画时间，propertyName动画属性translationX，valueFrom原来的值，valueTo变化后的值,valueType值的类型是floatType还是intType这些属性. 标签代表一个AnimatorSet,在set标签内默认按照从上到下顺序加载不同的动画（就是在set设置android:ordering=”sequentially”）,如果你想同步进行就设置android:ordering=”together” 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:ordering=\"sequentially\"&gt; &lt;objectAnimator android:duration=\"500\" android:propertyName=\"scaleY\" android:valueFrom=\"100f\" android:valueTo=\"1f\" android:valueType=\"floatType\" /&gt; &lt;set android:ordering=\"together\"&gt; &lt;objectAnimator android:duration=\"500\" android:propertyName=\"scaleY\" android:valueFrom=\"1f\" android:valueTo=\"100f\" android:valueType=\"floatType\" /&gt; &lt;/set&gt;&lt;/set&gt; xml代码写好了，然后实现可以在类中调用 123Animator animator = AnimatorInflater.loadAnimator(mContext, R.animator.animator);animator.setTarget(mImageView);animator.start(); 最后通过够用AnimatorInflate.loadAnimator，参数分别是Context和R.animator.animator ViewPropertyAnimator在android3.1系统推出了view通过调用animator方法来设置不同的动画 12mImageView.animate().alpha(0f).setDuration(500);//这时候不用start即可mImageView.animate().x(100).y(100).setDuration(500);//这时候不用start即可 但是这时候的链接不支持透明度从1f到0f再到1f。就算一个控件多次调用animate().alpha也会以最后一次动画为准。有点鸡肋。 总结 上述分别讲述了帧动画，补间动画，属性动画的ValueAnimator，ObejectAnimator 和AnimatorSet，还有属性动画的xml写法。 从性能效率上来看，优先考虑使用属性动画。","categories":[],"tags":[{"name":"PropertyAnimation","slug":"PropertyAnimation","permalink":"http://www.lanyimi.com/source/tags/PropertyAnimation/"}]},{"title":"greenDAO","slug":"greenDAO","date":"2016-11-22T09:07:51.000Z","updated":"2016-11-25T13:14:12.418Z","comments":true,"path":"2016/11/22/greenDAO/","link":"","permalink":"http://www.lanyimi.com/2016/11/22/greenDAO/","excerpt":"","text":"GreenDaoGreenDao3.1.0使用案例包含（增删查改，升级数据库），3.+版本比2.+更加便捷生成DaoMaster和DaoSession本文项目地址 ##首先让你的android studio配置Greendao数据库在build.gradle目录下12345dependencies &#123; classpath 'com.android.tools.build:gradle:2.1.0' classpath 'org.greenrobot:greendao-gradle-plugin:3.1.0'&#125; 在app/build.gradle目录下设置 123456789101112apply plugin: 'org.greenrobot.greendao'android &#123; greendao&#123; schemaVersion 1 //数据库 版本号 targetGenDir 'src/main/java' //生成DaoMaster类文件夹 daoPackage 'com.ppjun.greendaotest.db' //生成DaoMaster类包名 &#125;&#125;dependencies &#123; compile 'org.greenrobot:greendao:3.1.0'&#125; 新建一个User类 12345678910111213@Entitypublic class User &#123; @Id(autoincrement = true) private Long id; @Property(nameInDb = \"username\") private String userName; @Property(nameInDb = \"password\") private String passWord; //generate set和get方法 toString方法 ...&#125; @Entity 代表数据库里面的USER表 @Id 主键 ,autoincrement=true 从0开始自增长。 @Property 表里面的内容 @Unique 唯一的 @Transient 不会被数据库持久化写进数据库 @NotNull 不为空 到此为止，sync gradle来执行greendao配置，下面开始讲解怎么使用 ##GreenDao使用 1234567891011121314151617181920212223242526272829public static final String DB_NAME = \"ppjun.db\";//数据库名称DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(context, DB_NAME, null);//实例化一个DevOpenhelper,相当于sqlit的SQliteOpenHelperDaoMaster daoMaster = new DaoMaster(helper.getWritableDb());//实例化DaoMasterDaoSession daoSession = daoMaster.newSession();//实例化DaoSessionUserDao userDao =daoSession.getUserDao(); //获取UserDao实例来对表user进行操作//add，这里的null 代表自增长的id，你还可以为user表插入unique的userid User user1 = new User(null, \"ag1\", \"123456\"); User user2 = new User(null, \"ag2\", \"123456\"); User user3 = new User(null, \"ag3\", \"123456\"); userDao.insert(user1); userDao.insert(user2); userDao.insert(user3); //update，这里更新id是3的user的名字，id从1开始的，在where来添加匹配条件 User user4 = userDao.queryBuilder().where(UserDao.Properties.Id.eq(3)).build().unique(); user4.setUserName(\"kk\"); userDao.update(user4);//delete，这里删除id是2的user List&lt;User&gt; userList2 = userDao.queryBuilder().where(UserDao.Properties.Id.eq(2)).build().list(); for (User user5 : userList2) userDao.delete(user5); //query，重新user表全部user List&lt;User&gt; userList = userDao.queryBuilder().build().list(); for (User user : userList) Log.i(TAG, user.toString()); 上面完成数据库基本操作。 ##下面来说GreenDao的升级数据库，在user表插入age 1、修改build.gradle下面的schemaVersion 2 2、在user类，新增age对象 1234567public class User &#123; @Id(autoincrement = true) private Long id; @Property(nameInDb = \"age\") private int age; //generate getter and setter &amp; toString&#125; 3、你要新建一个类MyDBHelper继承DaoMaster.OpenHelper,在类的构造函数传入Context，super(context,DB_NAME,null);还要重写onUpgrade方法（注意这里的参数一是Database），然后创建表(传入true，这里使用IF NOT EXISTS)不用担心表不存在，还有执行增加age列sql语句 db.exeSQL(“ALTER TABLE USER ADD COLUMN age”); 1234567891011121314public class MyDBHelper extends DaoMaster.OpenHelper &#123; public MyDBHelper(Context context) &#123; super(context, DB_NAME,null); &#125; @Override public void onUpgrade(Database db, int oldVersion, int newVersion) &#123; super.onUpgrade(db, oldVersion, newVersion); NoteDao.createTable(db,true); db.execSQL(\"ALTER TABLE NOTE ADD COLUMN age\"); &#125;&#125; 这时候的DaoMaster.DevOpenHelper改为自定义DBHelper，这样子升级数据库就不会丢失原来的数据了 12DBHelper dbHelper = new DBHelper(context);DaoMaster daoMaster = new DaoMaster(dbHelper.getWritableDb()); 本文项目地址","categories":[],"tags":[{"name":"greendao3","slug":"greendao3","permalink":"http://www.lanyimi.com/source/tags/greendao3/"}]},{"title":"How to use retrofit2?","slug":"retrofit","date":"2016-11-21T02:16:15.000Z","updated":"2016-11-21T03:19:36.795Z","comments":true,"path":"2016/11/21/retrofit/","link":"","permalink":"http://www.lanyimi.com/2016/11/21/retrofit/","excerpt":"","text":"retrofit2.1 retrofit安全的http客户端for Android和java. 如何使用Retrofit在app/build.gradle 12345compile 'com.squareup.retrofit2:retrofit:2.1.0'compile 'com.squareup.retrofit2:converter-gson:2.1.0'compile 'com.squareup.retrofit2:adapter-rxjava:2.1.0'compile 'io.reactivex:rxandroid:1.2.1'compile 'io.reactivex:rxjava:1.2.1' 新建Git包，含括Git.java ，GitApi.java 和GitService.java 123Git.java（单例类，包括retrofit GitService的实例化）GitApi.java (请求需要的URl)GitService.java （各种get post方法） Git.java 新建单例类Git 私有化构造函数， 新建public static final Git mGit; 和public static Git getInstane()的方法 新建全局变量mGitService ，和getService的方法返回mGitService??? 在Git的构造函数需要实例化 retrofit主要用到几个参数包括url，okhttpClient，new GsonConverterFactory?RxJavaCallAdapterFactory ，还要实例化GitService。 123456789101112131415161718192021222324252627282930313233343536public class Git &#123; private static volatile Git mInstance = new Git(); private GitService mGitService; private Git() &#123; OkHttpClient.Builder client= new OkHttpClient().newBuilder(); OkHttpClient c= setCertificates(client,new Buffer().writeUtf8(GitApi.CER).inputStream()).build(); Retrofit retrofit = new Retrofit.Builder().baseUrl(GitApi.BASE_URL) .client(c) .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .build(); mGitService = retrofit.create(GitService.class); &#125; public static Git getInstance() &#123; if (mInstance == null) &#123; Git mIns = mInstance; synchronized (Git.class) &#123; if (mIns == null) &#123; mIns = new Git(); mInstance = mIns; &#125; &#125; &#125; return mInstance; &#125; public GitService getGitService() &#123; return mGitService; &#125; &#125; ​ GitApi.java这里的URL需要注意要以/结尾 要以/结尾 要以/结尾。这样子GitService注解里面的就不用/开头了 1public static final String BASE_URL=\"https://api.github.com/\"; GitService.java要写这个类首先学会@GET @POST @FormUrlEncoded这些注解。 123456789101112@GET(\"users/&#123;user&#125;/repos\")Call&lt;List&lt;Repos&gt;&gt; listRepos(@Path(\"user\") String user);@GETCall&lt;String&gt; get(@Url String url);@POST@FormUrlEncodedCall&lt;GitReturnCode&gt; init(@Url String url, @Field(\"id\") String id, @Field(\"key\") String key); 详细的各种注解要看这里retrofit注解的使用 最后在Presenter层调用方法，返回List 123456789101112Git.getInstance().getGitService().listRepos(\"gdmec07120731\").enqueue(new Callback&lt;List&lt;Repos&gt;&gt;() &#123; @Override public void onResponse(Call&lt;List&lt;Repos&gt;&gt; call, Response&lt;List&lt;Repos&gt;&gt; response) &#123; Log.i(\"TAG\", response.body().get(0).getName()); &#125; @Override public void onFailure(Call&lt;List&lt;Repos&gt;&gt; call, Throwable t) &#123; Log.i(\"TAG\", t.toString()); &#125; &#125;);","categories":[],"tags":[{"name":"retrofit2","slug":"retrofit2","permalink":"http://www.lanyimi.com/source/tags/retrofit2/"}]},{"title":"5mins熟悉mvp架构","slug":"mvp","date":"2016-11-01T08:48:10.000Z","updated":"2016-11-22T09:10:18.830Z","comments":true,"path":"2016/11/01/mvp/","link":"","permalink":"http://www.lanyimi.com/2016/11/01/mvp/","excerpt":"","text":"MvpDemo简单的mvp架构登录demo，根据功能分包，参考自google mvp 主要面向有mvp经验的读者，阅读时间大约 5 min mvp 的思想是把显示和业务逻辑从activity，fragment这些View中分离。让model和view的通信通过Presenter来搞定，这样子就降低了一个activity成千代码量的可能，以后修改业务逻辑，新增方法只要model层实现好，然后在Presenter层暴露接口给view调用就好了，mvp相比mvc会提项目结构易读性，也有一些不足就是要多写类来协助开发，不太熟悉的同学就会拉慢开发速度。1View&lt;===&gt;Presenter&lt;===&gt;Model 项目主要有以下类组成123456----login |----LoginActivity.java |----LoginContract.java |----LoginPresenter.java----BaseView.java----BasePresenter.java 新建类BaseView.java1234public interface BaseView&lt;T&gt; &#123; //在view层 给LoginConstract.Presenter赋值 void setPresenter(T presenter);&#125; 新建类BasePresenter.java1234public interface BasePresenter &#123;//start方法表示进行数据初始化，这方法感觉没用 void start();&#125; 这两个base类是所有模块都用到的基类。这里我们就不动它，然后具体某个模块(比如登陆模块用到的方法就在Login这个包里面新建LoginConstract。 然后新建两个接口分别是继承BaseView的view接口，注意这里的BaseView带泛型指向下面同级新建好的Presenter就行了。 以及继承BasePresenter的Presenter接口，把操作ui界面的方法和业务逻辑的方法写进对应的view和presenter接口，就有了下面的LoginConstract类) 新建类LoginConstract.java1234567891011121314public interface LoginConstract&#123; public interface View extends BaseView&lt;Presenter&gt;&#123; void showProgressBar();//show进度条的方法 void hideProgressBar void onLoginSuccess();//登录成功的方法 void onLoginError(); //... &#125; public interface Presenter extends BasePresenter&#123; void login(String username,String password); //登录的方法 //... &#125;&#125; 新建类LoginPresenter.javaLoginPresenter会实现LoginContract.Presenter接口，在login方法写网络请求的逻辑代码。可以理解为持有view对象，并且操作业务逻辑(登陆，注册，获取列表数据)的类，有一个LoginConstract.View的全局变量mView。这个对象要赋值才能使用，所以我们会在LoginPresenter构造方法给mView赋值。并且在构造函数调用mView的setPresenter给View层的负责登陆业务的Presenter赋值。 12345678910111213141516public class LoginPresenter implements LoginConstract.Presenter &#123; private LoginConstract.View mView; public LoginPresenter(LoginConstract.View view) &#123; this.mView = view; this.mView.setPresenter(this); &#125; @Override public void login(final String username, final String password) &#123; //判断username pwd这些参数合法性 //期间调用mView.showProgressBar();等操作ui的方法 //发送网络请求 &#125; 新建类LoginActivity.java类要实现LoginConstract.View接口，期间会实现大量在LoginConstract.View的ui方法例如showProgressBar()啊。并且有2个全局变量分别是LoginConstract.Presenter类型的mPresenter 和LoginPresenter类型的mLoginPresenter变量。 在setPresenter要给mPresenter 赋值。 在onCreate要实例化就是要new一个mLoginPresenter，之后才能在点击事件调用login方法拉起登录，在点击事件调用mPresenter.login(…);。 然后就是正常逻辑的initViews() 和initListeners()方法，给控件实例化，和注册点击事件等。 1234567891011121314151617181920212223242526272829303132333435363738public class LoginActivity extends Activity implements LoginConstract.View &#123; private LoginConstract.Presenter mPresenter; private LoginPresenter mLoginPresenter; private EditText mUsername; //... @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); initViews(); initListeners(); &#125; private void initListeners() &#123; mLogin.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; mPresenter.login(mUsername.getText().toString(), mPassword.getText().toString()); &#125; &#125;); &#125; private void initViews() &#123; mUsername = (EditText) findViewById(R.id.ed_username); //... mLoginPresenter = new LoginPresenter(this); &#125; @Override public void setPresenter(LoginConstract.Presenter presenter) &#123; this.mPresenter = presenter; &#125; &#125; 实现了LoginConstract.View接口就要重写setPresenter方法给LoginConstract.Presenter 类型的全局变量赋值。要调用mPresenter.login方法必须先实例化mLoginPresenter这个对象。 注意，mPresenter主要是为了让view绑定Presenter，一定要先实例化mLoginPresenter，因为在LoginPresenter的构造函数中，会传入mView,才会让LoginPresenter的mView有值，执行LoginPresenter里面的login方法不会报错。 &gt; 注释 LoginConstract.View mView; 掌控view操作ui的所有方法的对象。 LoginConstract.Presenter mPresenter; 掌控view中操作业务逻辑的所有方法的对象。 LoginPresenter mLoginPresenter; 让view绑定Presenter","categories":[],"tags":[{"name":"android.mvp","slug":"android-mvp","permalink":"http://www.lanyimi.com/source/tags/android-mvp/"}]},{"title":"5mins接入微信支付","slug":"5分钟接入微信支付","date":"2016-10-28T08:36:45.000Z","updated":"2016-11-22T09:12:38.958Z","comments":true,"path":"2016/10/28/5分钟接入微信支付/","link":"","permalink":"http://www.lanyimi.com/2016/10/28/5分钟接入微信支付/","excerpt":"","text":"现在app最流行微信支付，支付宝支付，都是大部分消费类型app计费方式首选。现在5分钟教你接入微信支付。 接入前请准备好 微信appid 微信appkey 微信商户id 微信商户APIkey 需要在商户后台自定义32位key 上传app的签名.jks文件 MD5值 官网微信支付demo下载链接 配置项目配置文件首先，把demo中的libammsdk.jar加入项目中libs文件夹，右击as library AndroidManifest.xml加入权限 123&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;&lt;uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\"/&gt;&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt; 注册广播接收器 &lt;receiver android:name=&quot;包名.AppRegister&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.tencent.mm.plugin.openapi.Intent.ACTION_REFRESH_WXAPP&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 注册支付结果回调actiivty ，此处activity命名规则必须是包名+wxapi.WXPayEntryActivity ，否则无法得到支付结果。 &lt;activity android:name=&quot;包名.wxapi.WXPayEntryActivity&quot; android:exported=&quot;true&quot; android:launchMode=&quot;singleTop&quot;/&gt; 在调用微信支付的activity 的intent-filter标签加上 1&lt;data android:scheme=\"微信appid\"/&gt; 调用支付方法前提，微信生成预订单prepay_id要在app服务器完成，这样子好处是客户端不保存微信appkey，商户key，商户id等信息让支付更加安全可靠。操作就是客户端把商品名称，金额提交给app服务器返回预订单。 在调用支付方法view定义 123456789101112131415161718192021222324252627282930313233343536373839 private PayReq mReq private IWXAPI mWxapi @Override protected void onCreate(Bundle savedInstanceState) &#123; mReq=new PayReq(); mWxapi=WXAPIFactory.createWXAPI(this,null);&#125; public void pay()&#123; //判断微信是否安装 if(!isSupportPay())&#123; return;&#125; //向app服务器提交商品名金额，获取预订单，商户id，加密信息，时间戳等后... mReq.appId = \"appid\"; mReq.partnerId = \"mch_id\"; mReq.prepayId = \"prepay_id\"; mReq.packageValue = \"Sign=WXPay\"; mReq.nonceStr =\"nonce_str\"; mReq.timeStamp = \"TimeStamp\"; mReq.sign = \"signParams\"; mWxapi.registerApp(\"appid\"); mWxapi.sendReq(req);//拉起微信支付界面&#125;private boolean isSupportPay()&#123; if(mWxapi.isWXAppInstalled()&amp;&amp;mWxapi.isWXAppSupportAPI())&#123; return true; &#125;else&#123; Toast.makeText(mContext, \"请安装最新版微信\", Toast.LENGTH_SHORT).show(); return false; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 WXPayEntryActivity.java private IWXAPI wxapi; public class WXPayEntryActivity extends Activity implements IWXAPIEventHandler &#123; @Overrideprotected void onCreate(Bundle savedInstanceState) &#123; wxapi = WXAPIFactory.createWXAPI(this, \"wxappid\"); wxapi.handleIntent(getIntent(), this); &#125; @Overrideprotected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent); wxapi.handleIntent(intent, this); &#125; @Overridepublic void onReq(BaseReq req) &#123; // TODO Auto-generated method stub&#125; //微信通知app客户端@Overridepublic void onResp(BaseResp resp) &#123; if (resp.getType() == ConstantsAPI.COMMAND_PAY_BY_WX) &#123; switch(resp.errCode)&#123; case 0: //支付成功 break; case -1: //未签名app break; case -2: //取消支付 break; default: //支付失败 break; &#125; &#125; &#125;&#125; 支付相关错误码如果resp.errCode返回-1，此时app签名和微信open平台签名文件的md5值不一致造成，所以要确保app使用open平台相同签名文件。 如遇到其他复杂情况可以清空微信app缓存，进行测试。","categories":[],"tags":[{"name":"微信支付","slug":"微信支付","permalink":"http://www.lanyimi.com/source/tags/微信支付/"}]},{"title":"EventBus3.0入门","slug":"EventBus3.0入门","date":"2016-10-12T01:39:32.000Z","updated":"2016-11-22T09:11:13.137Z","comments":true,"path":"2016/10/12/EventBus3.0入门/","link":"","permalink":"http://www.lanyimi.com/2016/10/12/EventBus3.0入门/","excerpt":"","text":"EventBus是一个在Android优化很好的事件总线，他简化Android的activity，fragment，thread，Service之间通信，代码体积小，质量更高。 总之，他可以代替handler发送msg和Message接受msg，还可以代替intent在activity，fragment等传递msg。 如何使用EventBus在app/build.gradle1compile 'org.greenrobot:eventbus:3.0.0' 然后在onCreate()注册eventbus，在onDestroy()取消注册。123protected void onCreate(Bundle savedInstanceState)&#123; EventBus.getDefault().register(MainActivity.this);//注册&#125; 1234protected void onDestory()&#123; EventBus.getDefault().unregister(MainActivity.this);//取消注册&#125; 同时在注册的界面接受msg，这里的方法名可以自定义，只要方法前有@Subscribe的注解。1234@Subscribepublic void getMessage(String msg)&#123; Log.i(TAG,msg);&#125; 如果有方法注解了@Subscribe，而没先注册就会在日志打印 12No subscribers registered for event class com.ppjun.demo.MessageEventNo subscribers registered for event class org.greenrobot.eventbus.NoSubscriberEvent 如果actiivty注册了eventbus，而没写一个方法被@Subscribe注解就会报异常 1Subscriber class com.ppjun.amapmaster.BActivity and its super classes have no public methods with the @Subscribe annotation 其中@Subscribe注解可以有以下几种情况： @Subscribe(sticky = true) 代表在activity用postSticky信息之后再注册evnetbus，要用这种sticky=true注解方法来接受msg,因为sticky默认为false的 @Subscribe(threadMode = ThreadMode.MAIN) 代表主线程或者子线程post信息的到activity的主线程。 @Subscribe(threadMode = ThreadMode.BACKGROUND) 如果发布线程是主线程，eventbus就会用一个后台子线程发送给主线程，如果发布线程是子线程，那么处理方法就在子线程执行。最后经过或者不经过线程切换都会原来的线程。 @Subscribe(threadMode = ThreadMode.POSTING) 不需要切换线程，发布线程和处理线程一样。简单来说在什么线程post就在什么线程处理。 @Subscribe(threadMode = ThreadMode.ASYNC) 处理方法在主线程和发布线程意外的线程执行，处理一些耗时的操作如网络请求。如果有必要还会开启线程池。 ​ post和postSticky的区别一般注册后，再post信息要用post，而在没注册前post信息，这时候还没有Subscriber，就要用postSticky。 12345678910111213141516171819202122Aactivity.javaprotected void onCreate(Bundle savedInstanceState)&#123; EventBus.getDefault().postSticky(\"msg from A\"); startActivity(new Intent(Aactivity.this,Bactivity.class));&#125;Bactivity.javaprotected void onCreate(Bundle savedInstanceState)&#123; EventBus.getDefault().register(this);&#125;@Subscribe(sticky = true) public void getMessage(String msg)&#123; Log.i(TAG,msg);//这里打印出 msg from A&#125;protected void onDestory()&#123; EventBus.getDefault.unregister(this);&#125; Subscribers的优先级要在同一中ThreadMode中 ，默认的priority是0，优先级更高的会被先执行。 1234@Subscribe(priority=1)public void getMessage(String a)&#123;&#125; 取消订阅者Subscriber通常由优先级更高的订阅者来取消低优先级的订阅者。 1234@Subscribepublic void onEvent(String msg)&#123; EventBus.getDefault().cancelEventDelivery(msg);&#125; EventBus的混肴12345678910-keepattributes *Annotation*-keepclassmembers class ** &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;&#125;-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125;# Only required if you use AsyncExecutor-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent &#123; &lt;init&gt;(java.lang.Throwable);&#125;","categories":[],"tags":[{"name":"eventbus","slug":"eventbus","permalink":"http://www.lanyimi.com/source/tags/eventbus/"}]},{"title":"android studio详细使用","slug":"AndroidStudio从入门到精通","date":"2016-10-10T01:31:58.000Z","updated":"2016-12-07T08:55:04.293Z","comments":true,"path":"2016/10/10/AndroidStudio从入门到精通/","link":"","permalink":"http://www.lanyimi.com/2016/10/10/AndroidStudio从入门到精通/","excerpt":"","text":"Android Studio谷歌官方推荐开发android的编译器，使用更强大的gradle脚本工具，支持Layout Editor更加直观的布局编辑，Constraint layout比relativelayout更加方便的相对布局，Apk Analyzer查看apk中dex体积等。 AndroidStudio下载链接 不同于eclipse，as是以一个project为一个窗口。 选择file-new-new project 新建as项目， 选择file-new-import project 导入eclipse项目， 选择file-open 打开as项目， 选择file-new-Project from Version Control-github 来导入git上的项目。 as的项目结构，app项目主目录 。 app/libs jar 存放位置， app/src/java 放java代码， app/src/res 放图片xml等文件， app/src/res/mipmap-xhdpi 用来放launcher的logo app/src/res/drawable-xhdpi 用来放项目用到的图片文件 app/build.gradle 负责定义项目的编译sdk版本，包名，版本号，打包签名，还有jar在maven上的引用。 build.gradle 负责整个引用项目的gradle插件版本。 settings.gradle 包含主项目和moudle项目 as设置as修改包名 选择show option menu就是绿色运行那个三角形下2行的那个齿轮按钮，把Compat Empty middle packages的改为不选中状态，修改包名java/com/xxx.xxx最后修改build.gradle上的applicationId为你的包名。 添加每个java类的头文件 在settings搜索File and Code Templates找到includle -file Header123456/** * Package :$&#123;PACKAGE_NAME&#125; * Description : * Author :$&#123;USER&#125; * Created at :$&#123;DATE&#125; $&#123;HOUR&#125;:$&#123;MINUTE&#125;. */ 自定义代码模板 在settings搜索 Live Templates 点开Android ，点击右上角绿色的加号，，例如我要添加一个swith的代码片段。 在Abbreviation 输入片段的缩写：如switchinit； 在description 输入片段作用的描述：如ontouchevent的switch语句。 然后在Template text输入代码: 12345678 switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_MOVE: break; case MotionEvent.ACTION_UP: break;&#125; as的快捷键，我选择default，下面是几个常用的快捷键 Ctrl+Alt+L format code Alt+Shift+鼠标光标 多行多光标编辑 Alt+enter 解决代码报错，用于强制类型转换，导包，生成方法等 引用aar包把aar包复制到libs文件夹下,修改module的build.gradle 注 ：apply plugin:com.android.library的项目才能gengerate出aar 12345678910repositories&#123; flatDir&#123; dirs 'libs' &#125;&#125;dependencies&#123; compile(name:'aaa.aar',ext:'aar')&#125; 排除依赖但出现依赖冲突时候，可以通过排除依赖解决： 123compile (name:'aaa',ext:'aar')&#123; exclude group:'com.android.support',module:'recyclerview-v7'&#125;//这样子可以解决aaa.aar包使用recyclerview，到此项目因为类重复而编译失败. dex分包（解决65k）12345678910111213buildConfig&#123; multiDexEnable true&#125;dependencies&#123; compile 'com.google.support:multidex:1.0.0'&#125;//自定义application继承MultiDexApplication。即可//或者在你原来的Application重写attachBaseContext方法加入//MultiDex.install(this); 移除没用资源123456buildTpyes&#123; release&#123; minifyEnable true shrinkResources true &#125; &#125; 忽略lint错误12345android&#123; lintOptions&#123; abortOnError true &#125;&#125; 声明编译java版本123456android&#123; compileOptions&#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 &#125;&#125; 签名配置12345678910111213141516171819202122232425signingConfigs&#123; release&#123; storeFile file(\"c:/xx.jks\") storePassword \"123456\" keyAlias \"xiaom\" keuPassword \"bjuaa\" &#125; debug&#123; storeFile file(\"c:/xx.jks\") storePassword \"123456\" keyAlias \"xiaom\" keuPassword \"bjuaa\" &#125;&#125;buildTypes&#123; release&#123; minifyEnabled true useProguard false shirkResources true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'&#125;&#125;","categories":[],"tags":[]},{"title":"retrofit注解使用","slug":"retrofit注解使用","date":"2016-10-08T03:00:00.000Z","updated":"2016-11-22T09:09:44.990Z","comments":true,"path":"2016/10/08/retrofit注解使用/","link":"","permalink":"http://www.lanyimi.com/2016/10/08/retrofit注解使用/","excerpt":"","text":"在用到retrofit请求json时，通常在GankService.java类用到@GET，@POST，@Path这些注解，具体怎么用，可以看看下面。 @GET 用于get请求 12@GET(\"user\")Observable&lt;Result&gt; getUsers(); @Query用于url后面?key=value 12@GET(\"user\")Observable&lt;Result&gt; getUsers(@Query(\"id\") String userId); 相当于 12@GET(\"user?id=userId\")Observable&lt;Result&gt; getUsers(); @Field@POST 用于post请求，我们通常都是post一个表单形式的参数。这时候就用到@Field来连接键值对，@FormUrlEncoded来告诉服务器这是表单提交参数。 123@FormUrlEncoded@POST(\"user\")Observable&lt;Result&gt; getUsers(@Field(\"id\") String userId); @Body会把自定义对象，作为requestbody，并转换成指定格式。 好像依赖了这个包com.squareup.retrofit2:converter-gson 就会被gson转换成json格式。 12@POST(\"users/new\")Call&lt;User&gt; createUser(@Body User user); @Partpart和multipart一起使用，用于文件上传 1234567@Multipart@PUT(\"user/photo\")Call&lt;User&gt; updateUser(@Part MultipartBody.Part photo, @Part(\"description\") RequestBody description);File file=new File(Environment.getExternalStorageDirectory(),\"aa.png\");RequestBody body=RequestBody.create(MediaType.parse(\"image/png\"),file);MultipartyBody.Part photo=MultipartBody.Part.createFromData(\"photo\",\"icon.png\",body); @PartMap用于多个文件上传，多个MultipartBody1234567891011@Multipart@PUT(\"user/photo\")Call&lt;User&gt; updateUser(@PartMap Map&lt;String RequestBody&gt; map, @Part(\"description\") RequestBody description);File file1=new File(Environment.getExternalStorageDirectory(),\"aa.png\");File file2=new File(Environment.getExternalStorageDirectory(),\"bb.png\");RequestBody body1=RequestBody.create(MediaType.parse(\"image/png\"),file1);RequestBody body2=RequestBody.create(MediaType.parse(\"image/png\"),file2);Map&lt;String ,RequestBody&gt; map=new HashMap&lt;&gt;();map.put(\"photos\",body1);map.put(\"photo2\",body2); @Hearders设置头文件内容 123@Headers(\"Cache-Control: max-age=640000\")@GET(\"widget/list\")Call&lt;List&lt;Widget&gt;&gt; widgetList(); 如果你要设置头文件多个内容 1234@Headers(&#123; \"Accept: application/vnd.github.v3.full+json\", \"User-Agent: Retrofit-Sample-App\"&#125;) @Header设置头文件内容 12@GET(\"user\")Call&lt;User&gt; getUser(@Header(\"Authorization\") String authorization); 等价于 123@Headers(\"Authorization :Authorization\")@GET(\"user\")Call&lt;User&gt; getUser();","categories":[],"tags":[{"name":"retrofit","slug":"retrofit","permalink":"http://www.lanyimi.com/source/tags/retrofit/"}]},{"title":"android hotfix","slug":"Android热修复","date":"2016-08-15T07:00:41.000Z","updated":"2016-11-21T06:21:46.930Z","comments":true,"path":"2016/08/15/Android热修复/","link":"","permalink":"http://www.lanyimi.com/2016/08/15/Android热修复/","excerpt":"","text":"Android热修复 热修复就是在用户运行app时候不知不觉，将apk里面错误代码纠正，无需再重新从应用市场下载最新版本。而且还有减少了开发者从打多个渠道包，上架多个应用渠道的工作。 热修复原理首先你的app必须经过分包（在eclipse你可以自定义ant分包，在as你可以用multix分包），把Application和Mainactivity放在主classes.dex，把Bug.class放在Classes2.dex，要修改Bug.class内容只要执行dx.bat命令得到新的Classes2.dex文件，在app正常运行时，使用ClassLoader加载类方法。 BaseDexClassLoader子类分为PathClassLoader加载已安装到系统的apk和DexClassLoader可以加载未安装到系统的jar、dex和apk。 1234567891011121314151617181920212223242526272829#baseDexClassLoader protected Class&lt;?&gt; findClass(String name)throws ClassNotFoundException&#123; Class clazz=pathList.findClassLIE(name); if(clazz==null) throw new ClassNotFoundException(name); return clazz;&#125;#DexPathList public Class findClass(String name)&#123; for(Element element:dexElements)&#123; if(dex!=null)&#123; Class clazz=dex.loadClassBinaryName(name,definingContext); if(clazz!=null)&#123; return clazz;&#125;&#125;&#125; return null;&#125;#DexFile public Class loadClassBinaryName(String name,ClassLoader loader)&#123; return defineClass(name,loader,mCookie);&#125;private native static Class defineClass(String name,ClassLoader loader,int cookie); 一个ClassLoader可以包含多个dex文件，每个dex文件是一个element，多个dex组成一个有序的dexElement数组，当找类的时候会遍历整个数组来找，如果在当前dex找到类了，就返回该类，不去其他dex找类了，所以补丁dex放在最前面遍历，不会覆盖这个类。 这里还有一个CLASS_ISPREVERIFIED 问题就是有其他类引用到Bug.class 要取消CLASS_ISPREVERIFIED 标记其他类。 CLASS_ISPREVERIFIED 是什么？A类调用到B类方法 AB都在同一个在同一个dex里面 A类就会打上CLASS_ISPREVERIFIED标记","categories":[],"tags":[]},{"title":"android插件开发","slug":"Android中的插件开发","date":"2016-08-09T08:57:38.000Z","updated":"2016-11-22T09:11:46.957Z","comments":true,"path":"2016/08/09/Android中的插件开发/","link":"","permalink":"http://www.lanyimi.com/2016/08/09/Android中的插件开发/","excerpt":"","text":"插件化的好处就是满足各类用户的特定需求，动态加载内容。好像锤子桌面里面有很多主题，如主题ABCD有的人喜欢安装A，有的人喜欢安装C这时候就用到插件开发，又比如qq有很多皮肤，有的是商务皮肤，有的是可爱皮肤，有的是运动皮肤，根据个人爱好下载不同的皮肤。 想获取已安装的app的apk，路径就在data/app/包名-1/base.apk qq就是这样子发送已安装的apk 以加载apk为例子插件可以以zip jar dex apk等形式存在，首先下载好插件的apk到你app缓存根目录 加载已安装的apk获取里面的资源文件先获取插件apk的context再获取里面资源。可以用到Context pluginContext=this.createPackageContext(“包名”,flag); 加载未安装的apk呢就用DexClassLoader 原理原理根据是普通apk里面的getResoure.getDrawable(R.drawable.bg);getResource肯定有获取apk资源的方法。查看系统代码发现 getResource里面根据AssetManager添加自己apk的路径返回resource，通过resource就可以访问R文件下的所有对象属性。 这里只要新建一个pluginResurces继承Resources和AssetManager. 让AssetManager.addAssetPath为插件apk的路径，通过pluginResurces构造函数实例化pluginResurces，插件Reources有了，就差插件R文件里面的属性id， 根据DexClassloader加载包名+R$drawable 获取class 再获取field判断field和插进R文件的属性相同就int drawableId=field.getInt(R.drawable.class); Drawable drawable= resource.getDrawable(drawableId);然后你的按钮就可以设置background了。","categories":[],"tags":[{"name":"插件开发","slug":"插件开发","permalink":"http://www.lanyimi.com/source/tags/插件开发/"}]},{"title":"Java反射","slug":"Java反射","date":"2016-07-15T03:28:51.000Z","updated":"2016-11-22T09:08:49.879Z","comments":true,"path":"2016/07/15/Java反射/","link":"","permalink":"http://www.lanyimi.com/2016/07/15/Java反射/","excerpt":"","text":"Java反射 http://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650236432&amp;idx=1&amp;sn=1da63ff74cb6082ffe3df5f344f9f5f1&amp;scene=0#wechat_redirect Java反射动态语言程序运行时，通过代码能改变程序结构或变量类型的语言，一般为动态语言。例如Perl,Python,Ruby是动态语言，反之c++,java,C#是静态语言。java有个特点能在运行时加载，编译期间完全未知的class。就是java程序运行时可以加载未知名称的class，获取类的构造方法，类属性，类方法。 java反射要让java程序运行，就要让java类被java虚拟机加载，java不被虚拟机加载，就不能正常运行。正常情况下，我们运行的所有程序在编译期间已经把那个类加载好了。java反射就是在程序编译期间不加载用到的类，而在程序运行的时候才加载这个类。使用的是在编译期并不知道的类。 反射的作用如果AB两个程序员合作，A写程序时用到B写的类，如果B没写A用到的类，A的代码就不能通过编译了，此时用到java反射机制，就可以让A在获取不到B写的类是，来让自己代码通过编译，就是在运行时才加载用到类。 反射的实质 java反射会将代码解析成java类，要使用java反射就要用到Class（大写C）这个类，当一个java类被加载,java虚拟机就会自动生成一个Class对象，通过Class对象我们就能获取加载到java虚拟机当前Class对象的构造方法，类方法，类属性。在运行期间拿到这个类的构造方法类属性和类方法 反射的使用获取本apk的类 123456789Class clazz=ClassLoader.getSystemClassLoader().loadClass(\"com.ppjun.Test\");//通过系统的 ClassLoader来加载Class，返回Class对象Coustructor constructor=clazz.getConstructor(String.class);//获取构造函数，参数是String类型 Object obj=constructor.newInstance(\"ppjun\"); //往构造函数传入参数ppjunMethod method=clazz.getMethod(\"display\",null);//获取clazz对象叫display的方法，没有返回值method.invoke(obj,null);//执行display的方法，会输出ppjun` 反射也可以在A.apk 调用B.apk的方法 首先在A.apk写一个类Share 1234567public class Share&#123;public void display(String s)&#123; Log.i(\"display\",\"from A.apk\")&#125;&#125; 然后再AndroidManifest的MainActivity的声明 1&lt;action android:name=\"com.ppjun\"&gt; 来扑抓这个activity 在B.apk 调用以下方法 123456789101112131415161718192021222324252627282930313233343536373839404142public void getFromRemote()&#123; Intent intent=new Intent(\"com.ppjun\"); PackageManager pm=getPackageManager(); List&lt;ResolveInfo&gt; resolveInfos=pm.queryIntentActivities(intent,0); ResolveInfo resolveInfo=resolveInfos.get(0); ActivityInfo activityInfo=resolveInfo.activityInfo; String packageName=activityInfo.packageName; String dexPath=activityInfo.applicationInfo.sourceDir; String dexOutputDir=getApplicationInfo().dataDir; String nativeLibraryDir=activityInfo.applicationInfo.nativeLibraryDir; ClassLoader classLoader=getClassLoader(); DexClassLoader dc1=new DexClassLoader(dexPath,dexOutputDir,nativeLibraryDir,classLoader); try&#123; Class&lt;?&gt; clazz=dcl.loadClass(packageName+\".Share\"); Constructor&lt;?&gt; constructor=clazz.getConstructor(); Object o=constructor.newInstance(); Method display=clazz.getMethod(\"display\",String.class); display.invoke(o,\"ppjun\") &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;","categories":[],"tags":[{"name":"java反射","slug":"java反射","permalink":"http://www.lanyimi.com/source/tags/java反射/"}]},{"title":"Git常用命令","slug":"Git常用命令","date":"2016-05-31T06:44:33.000Z","updated":"2016-11-22T09:11:03.180Z","comments":true,"path":"2016/05/31/Git常用命令/","link":"","permalink":"http://www.lanyimi.com/2016/05/31/Git常用命令/","excerpt":"","text":"Git命令 git config –global user.name “username” git config –global user.email “email” 这两句会帮你电脑的所有git项目都和你账号关联起来，当然你可以不要–global，就让当前项目和git关联起来 git init 新建.git到当前文件夹 git status 查看当前项目文件状态，有没有修改，有没有加入缓冲区等。 git clone xxx.git 克隆项目到本地 git add . 添加全部文件到缓存区 git commit -m “注释” 添加注释 git log 查看注释 git log –pretty=oneline 单行输出log git push -u origin master 第一次提交项目的到远程仓库 git push origin master 再次提交项目代码到远程仓库上 git tag xx 给当前分支创建一个tag 以后就能退回到这个tag的代码了 git branch 查看当前分支 *master指向master分支 git branch a 创建 a分支 git checkout a 转到a分支 git branch -b a 创建并转到a分支 git branch -d a 删除a分支 git branch -D a 在没有合并分支代码到master代码，或者无法删除分支时，强制删除分支a git merga 合并代码先转到master分支，再git merga a 的分支代码到master分支代码 git checkout tagname 让分支代码回到tag是tagname那时候的代码 更新时间 2016年10月18日16:44:56 git checkout – readme.txt 文件没提交到缓冲区时，让readme.txt回到修改前。 git reset HEAD readme.txt 让提交文退出缓冲区，再执行git checkout – readme.txt，回到修改前。 git remote add origin git@github… 添加文件夹到远程仓库 git merge –no-ff -m “merge with no-ff” dev 不删除dev分支，并把dev分支，合并到当前分支。 git reflog 查看全部历史commit信息 git reset –hard 63D232 回到 63D232 那一步 git stash 当你添加新功能一半时，要修补bug，你要想把dev分支保存起来，新增修复issure分支，合并到dev分支，在合并到master分支，最后了来到dev分支，把当时stash起来的 内容用git stash pop 恢复回来。 git remote -v 查看远程仓库的信息 git push origin branch-name 提交的到远程分支 git checkout -b branch-name origin/branch-name 创建远程分支。 git branch –set-upstream branch-name origin/branch-name 关联本地分支和远程分支 git pull 更新本地分支 创建tag 就是为了方便取出tag名的版本，实际是利用hard到特定的commit号，例如232EDE，分支是移动的 ，tag是不能移动的。 git tag 查看该分支的所有tag 给固定的commit id打上tag 首先用git log –pretty=oneline –abbrev-commit查看全部commit id git tag v1.2 3622EE git show v1.0 查看v1.0标签信息，包括commit id author git tag -a -m “tips” commit id 创建的标签都是在本地，不会自动推送的远程， git tag -d v1.0 删除指定tag，先删除本地tag，再删除远程tag git push origin v1.0 推送指定标签到远程 git push origin –tags 推送全部标签到远程 git push origin :refs/tags/v0.9 git clone git@github.com xxx.git 克隆远程仓库项目到本地、 git config –global color.ui true 界面文字多彩颜色 在项目根目录下编辑.gitignore文件，要忽略的文件放进去。一般是忽略程序编辑生产的文件，还有你不想提交远程仓库的文件 用SSH远程提交代码打开git bash就是git自带的终端，输入ssh Rc3@ppjun MINGW64 ~/Desktop $ ssh usage: ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec] [-D [bind_address:]port] [-E log_file] [-e escape_char] [-F configfile] [-I pkcs11] [-i identity_file] [-L address] [-l login_name] [-m mac_spec] [-O ctl_cmd] [-o option] [-p port] [-Q cipher | cipher-auth | mac | kex | key] [-R address] [-S ctl_path] [-W host:port] [-w local_tun[:remote_tun]] [user@]hostname [command]`` 这是代表你已安装ssh。 输入命令ssh-keygen -t rsa生成ssh密钥，连续按三个Enter Rc3@ppjun MINGW64 ~/Desktop $ ssh-keygen -t rsa Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/Rabbit/.ssh/id_rsa): 打开C:\\Users\\Rabbit.ssh 找到id_rsa.pub复制里面的https://github.com/settings/keys 点击 new SSH key的key里面-保存。 最后输入ssh -T git@github.com，结果如下代表你添加好SSH到你git上面了。 Rc3@ppjun MINGW64 ~/Desktop $ ssh -T git@github.com Hi gdmec07120731! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 配置别名–global是对用户所有项目生效 用例如以下的公式 1234567git config --global alias.co checkout //用git co 代替 git checkoutgit config --global alias.st status //用git st 代替 git statusgit config --global alias.br branchgit config --global alias.cm commit git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit\"//配置log 搭建远程GIT服务器 相当于github远程托管 强烈建议linux的机器，几条命令就可以搭建好了。 用apt-get下载git sudo apt-get install git 新增git用户 sudo adduser git 拿到所有登录用户的id_rsa.pub 公钥，放在/home/git/.ssh/authorized_keys文件夹里面 初始化git仓库，选定一个文件夹作为仓库文件夹比如GitRepository/sample,在GitRepository下输入sudo git init –bare sample.git","categories":[],"tags":[]},{"title":"Gradle配置多渠道打包","slug":"gradle多渠道打包","date":"2016-05-30T12:32:15.000Z","updated":"2016-11-22T09:10:50.001Z","comments":true,"path":"2016/05/30/gradle多渠道打包/","link":"","permalink":"http://www.lanyimi.com/2016/05/30/gradle多渠道打包/","excerpt":"","text":"Gradle多渠道打包 前言，多渠道打包的作用在于统计哪个app市场最多用户量下载量，推广效果最好。 编译工具：AndroidStudio 2.2preview 1gradle版本: gradle-2.10 打包原理：通过修改Androidmanifest.xml 自定义meta值来统计不同市场。 下面是总结的打包流程： 1. 在Androidmanifest.xml中Application标签下新增meta标签，name根据你的统计方式来定义，你可以用你app名（PPJUN_CHANNEL），如果你用友盟的统计name就要用UMENG_CHANNEL了。 自家自定义 &lt;meta-data android:name=&quot;PPJUN_CHANNEL&quot; android:value=&quot;{UMENG_CHANNEL_ID}&quot;/&gt; 友盟统计 &lt;meta-data android:name=&quot;UMENG_APPKEY&quot; android:value=&quot;123&quot;/&gt; &lt;meta-data android:name=&quot;UMENG_CHANNEL&quot; android:value=&quot;{UMENG_CHANNEL_ID}&quot;/&gt; 2. 设置build.gradle在app的build.gradle设置 android{ ... //配置签名信息 signingConfigs { release { keyAlias &apos;ppjun&apos; keyPassword &apos;ppjun123&apos; storeFile file(&apos;C:/Users/Rabbit/Desktop/umeng_message201603291611_v2.8.0/LabelView/app/ppjun.jks&apos;) storePassword &apos;ppjun123&apos; } } //配置签名apk优化 buildTypes { release { zipAlignEnabled true minifyEnabled true shrinkResources true proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; signingConfig signingConfigs.release } } //配置渠道号 productFlavors { baidu {} google {} wandoujia {} xiaomi {} } //关联渠道号和Androidmani.xml productFlavors.all { flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_ID: flavor.name] } } ps：signingConfigs这个方法一定要写在buildTypes方法前，不然不能通过clean。 3.修改apk名如果要打包出app_v1.0_1_20160101_xiaomi.apk这样子的包名在build.gradle android{ ... applicationVariants.all { variant -&gt; variant.outputs.each { output -&gt; // 重命名产出的apk文件 def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith(&apos;.apk&apos;)) { File outputDirectory = new File(outputFile.parent); def fileName if (variant.buildType.name == &quot;release&quot;) { fileName = &quot;app_v${defaultConfig.versionName}_${defaultConfig.versionCode}_${packageTime()}_${variant.productFlavors[0].name}.apk&quot; } else { fileName = &quot;app_v${defaultConfig.versionName}_${defaultConfig.versionCode}_${packageTime()}_debug.apk&quot; } output.outputFile = new File(outputDirectory, fileName) } // 删除unaligned apk if (output.zipAlign != null) { output.zipAlign.doLast { output.zipAlign.inputFile.delete() } } } } } //在android外层 def packageTime() { return new Date().format(&quot;yyyyMMdd&quot;, TimeZone.getTimeZone(&quot;UTC&quot;)) } 4.在Terminal运行命令先运行，clean项目 gradlew clean 成功后再运行，开始正式打包 gradlew assembleRelease","categories":[],"tags":[]},{"title":"U8SDK笔记","slug":"U8SDK开发笔记","date":"2016-03-28T02:53:17.000Z","updated":"2016-11-22T09:09:30.375Z","comments":true,"path":"2016/03/28/U8SDK开发笔记/","link":"","permalink":"http://www.lanyimi.com/2016/03/28/U8SDK开发笔记/","excerpt":"","text":"什么是U8SDK集成各个渠道比如（uc,小米，360）的sdk ，一次接入，打包出不同渠道的APK，大大减少游戏接入渠道的繁琐操作。 统一的接入框架，各个SDK的接入 一键打包工具(python)，统一的登录验证中心支付中心，多个平台（unity,coco2dx）的支持. 工作原理初始化时根据不同渠道U8Server自定义U8id,U8key分配给U8SDKU8SDK抽象层实现各个渠道的登录，获取登录信息后 u8server登录验证返回验证结果，返回给游戏。U8SDK调用各个渠道的支付后，渠道支付首先通知U8server,U8server再通知游戏服务器。 打包工具用到的jar等aapt.exe,android.jar,apktool.jar,baksmail.jar,dx.bat,zipalign.exe 工作流程游戏母包接入U8sdk,反编译母包，复制各个渠道sdk的res，assets，资源到母包，各个渠道.dx转smali后复制到母包，合并AndroidManifest.xml权限，Service,Activity等。修改包名（.activity，.service），合并资源后重新生成R文件，回编译母包，签名母包。","categories":[],"tags":[{"name":"U8SDK","slug":"U8SDK","permalink":"http://www.lanyimi.com/source/tags/U8SDK/"}]},{"title":"Dagger2笔记","slug":"Dagger2-笔记","date":"2016-03-23T03:39:14.000Z","updated":"2016-11-22T09:11:23.523Z","comments":true,"path":"2016/03/23/Dagger2-笔记/","link":"","permalink":"http://www.lanyimi.com/2016/03/23/Dagger2-笔记/","excerpt":"","text":"本文摘要自http://jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0519/2892.html目前安卓开发最新技术用到Retrofit网络请求框架，Rxjava异步处理，OkHttp网络请求，加上Gson解析，MVP项目架构，Lambda语法，Dagger2依赖注入，ButterKnife控件的依赖等 什么是Dagger2Dagger2是Dagger1的分支，由谷歌公司接手开发，目前的版本是2.0。Dagger2是受到AutoValue项目的启发。 刚开始，Dagger2解决问题的基本思想是：利用生成和写的代码混合达到看似所有的产生和提供依赖的代码都是手写的样子。 依赖注入好处依赖注入好处就是大大方便解耦，方便修改代码，为什么要用Dagger2利用编译期的注解处理来生成依赖注入的代码，尽可能的减少了反射的使用，提高app性能。 Dagger2 使用在AndroidStudio 使用在build:gradle(Moudle:app) 1234567 apply plugin: 'com.neenbedankt.android-apt' dependencies &#123; compile 'com.google.dagger:dagger:2.1' // dagger2 apt 'com.google.dagger:dagger-compiler:2.1' // dagger2&#125; 在build:gradle(Project:项目名)1234 dependencies &#123; classpath 'com.android.tools.build:gradle:2.1.0-alpha3' classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'&#125; 以上配置完毕 Dagger2 关键词 @Inject 通常需要依赖的地方使用这个注解，换句话来说它告诉dagger这个类或者字段需要依赖，这样子 dagger就会造这个类的实例来满足依赖。例如在MainActivity类里 实例化 GitHubService ,下面就可以直接使用mGitHubService。12@InjectGitHubService mGitHubService; @Module Modules类里面的方法专门提供依赖，所以我们定义一个类用@Module注解，这样Dagger构建类的实例的时候，就知道从哪里找到需要的依赖，module的一个重要特征是他们设计为分区并结合使用，比如在Modules包下 有MainModule ,ApiModule或者DBModule这些类都注解了@Module12@Modulepublic class ApiModule &#123; @Provides 我们为在Module类中 定义的方法使用这个注解 ，来告诉dagger我们构造对象并且提供这些方法依赖123456@Modulepublic class ApiModule &#123; @Provides @Singleton protected GitHubService provideGitHubService() &#123; @Component @Component从根本上来说是一个注解器，也就是说@Inject和@Module的桥梁，它的主要作用就是连接这两个部分，@Component可以提供所有定义了类型的实例，比如：我们必须用@Component注解一个接口，然后列出所有的@Module组成改组件，如果缺失任何一块都会在编译的时候报错，所有的组件都可以通过他的@Module知道依赖范围。例子中定义DemoComponent接口 用@Component注解所有的@Module类123@Singleton@Component(modules = &#123;MainModule.class, ApiModule.class&#125;)public interface DemoComponent extends DemoGraph &#123; @Scope Dagger可以通过自定义注解来限定注解作用域，这是一个非常强大的特点，，因为就如前面说的一样，没必要让每个对象都去了解如何管理他们的实例，在Scope例子中，我们自定义@PerActivity注解一个类，所以这个对象存活时间就和activity一样，简单来说就是我们定义所有范围的粒度（@Perfragment,@preUser等） @Qualifier 当类的类型不足以鉴别一个依赖的时候，我们就可以用这个注解来标示，例如：我们会用不同类型的Context 所以我们就可以定义 Qualifier注解@ForApplication 和@ForActivity这样当注入一个Context的时候，我们就可以告诉dagger我们想要哪种类型的Context","categories":[],"tags":[{"name":"Dagger2","slug":"Dagger2","permalink":"http://www.lanyimi.com/source/tags/Dagger2/"}]},{"title":"android studio配置lambda","slug":"Android-Studio使用Lambda表达式","date":"2016-02-26T09:51:51.000Z","updated":"2016-11-22T09:12:06.023Z","comments":true,"path":"2016/02/26/Android-Studio使用Lambda表达式/","link":"","permalink":"http://www.lanyimi.com/2016/02/26/Android-Studio使用Lambda表达式/","excerpt":"","text":"1、什么是LambdaJava 8的一个大亮点是引入Lambda表达式，使用它设计的代码会更加简洁。当开发者在编写Lambda表达式时，也会随之被编译成一个函数式接口。下面这个例子就是使用Lambda语法来代替匿名的内部类，代码不仅简洁，而且还可读。_来源百度百科 使用Lambda前1234567button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //dosomething &#125; &#125;); 使用lambda后1234button.setOnClickListener( v -&gt; &#123; //dosomething&#125;); 2、AndroidStudio怎么配置Lambda 在build.gradle(Moudle:app) 123456789apply plugin:'me.tatarka.retrolambda'android&#123; compileOptions&#123; sourceCompatibility org.gradle.api.JavaVersion.VERSION_1_8 targetCompatibility org.gradle.api.JavaVersion.VERSION_1_8 &#125;&#125; 在build.gradle(Project:项目名) 123456789buildscript &#123;dependencies &#123; classpath 'com.android.tools.build:gradle:2.0.0-beta6' classpath 'me.tatarka:gradle-retrolambda:3.2.4'&#125;&#125; 以上配置完毕。","categories":[],"tags":[{"name":"lambda","slug":"lambda","permalink":"http://www.lanyimi.com/source/tags/lambda/"}]},{"title":"如何科学上网","slug":"如何科学上网","date":"2016-02-24T03:33:51.000Z","updated":"2016-11-22T09:09:03.613Z","comments":true,"path":"2016/02/24/如何科学上网/","link":"","permalink":"http://www.lanyimi.com/2016/02/24/如何科学上网/","excerpt":"","text":"在window上的科学上网方法一 ：影梭ShadowSocks1、下载shadowsocks软件 百度网盘下载链接 2、打开shadowsocks 输入shadowsocks账号 ps ：免费账号获取方式 打开链接 进入ishadowsocks （每6小时更换一次密码 中午12点左右换一次的） 方法二 ：蓝灯LanternLantern是一个免费的应用程序。它能帮助你随时随地快速、可靠、安全地访问互联网。 蓝灯官网（需翻墙） https://getlantern.org/蓝灯github https://github.com/getlantern/lantern 下载window版本安装后无需配置就可以直接科学上网 https://raw.githubusercontent.com/getlantern/lantern-binaries/master/lantern-installer-beta.exe","categories":[],"tags":[{"name":"shadowsock","slug":"shadowsock","permalink":"http://www.lanyimi.com/source/tags/shadowsock/"}]},{"title":"Cocos2d-x接入第三方SDK","slug":"Cocos2d-x接入第三方SDK","date":"2016-01-10T16:00:00.000Z","updated":"2016-11-22T09:11:34.789Z","comments":true,"path":"2016/01/11/Cocos2d-x接入第三方SDK/","link":"","permalink":"http://www.lanyimi.com/2016/01/11/Cocos2d-x接入第三方SDK/","excerpt":"","text":"Cocos2d-x游戏接入安卓第三方SDK1.概述U3D游戏和Cocos2dx手游都会接入不同渠道的支付方式，本文运用jni知识以360渠道接入作为演示。 2.环境OS: win10IDE: EclipseAdnroid NDK:r10ecocos2d-x-3.9 3.创建Cocos2d-x工程运行命令 cocos new -p com.ohj.cocos2dx360 -l cpp -d Cocos2dx360SDK 然后进入Cocos2dx360SDK-MyCppGame-proj.android执行build_native.py 生成.so文件 编译成功后你会在libs-armeabi看到libcocos2dcpp.so 最后导入Eclipse，是导入2个工程 ，分别是MyCppGame和库libcocos2dx。（导入EC时注意不要复制工程项目到工作区间） 4.开始配置360SDK导入assets、lib文件，配置好AndroidManifest.xml 在AppActivity.java 的OnCreate初始化 123456789 @Overrideprotected void onCreate(Bundle savedInstanceState) &#123; // TODO Auto-generated method stub super.onCreate(savedInstanceState); mContext = this; Matrix.init(this); &#125; 接着创建静态登录方法，直接调用360的登录方法1234567public static void login360()&#123; Intent intent = getLoginIntent(); IDispatcherCallback callback = mLoginCallback; Matrix.execute(mContext, intent, callback); &#125; 5.jni调用登录方法在classes下创建SDK360.h 和SDK.cpp SDK360.h 代码如下12345678910111213141516171819 #ifndef __SDK360_H__ #define __SDK360_H__ #include \"cocos2d.h\" #include &lt;string&gt; using namespace cocos2d; using namespace std; class SDK360 &#123; public: SDK360(); virtual ~SDK360();static SDK360* getInstance();void login(); &#125;; #endif // __SDK360_H__ SDK360.cpp 代码如下123456789101112131415161718192021222324252627282930313233343536373839 #include \"SDK360.h\" #include &lt;string&gt; #include &lt;jni.h&gt; #include \"cocos2d.h\" #include \"platform/android/jni/JniHelper.h\" using namespace std; static SDK360* mInstance=NULL; SDK360::SDK360() &#123; &#125; SDK360::~SDK360() &#123; &#125; SDK360* SDK360::getInstance() &#123;if(NULL==mInstance)&#123;mInstance=new SDK360();&#125;return mInstance; &#125; void SDK360::login() &#123; #if(CC_TARGET_PLATFORM==CC_PLATFORM_ANDROID) JniMethodInfo minfo; bool isHave=JniHelper::getStaticMethodInfo(minfo,\"org/cocos2dx/cpp/AppActivity\",\"login360\",\"()V\");if(!isHave)&#123; &#125;else&#123; minfo.env-&gt;CallStaticVoidMethod(minfo.classID,minfo.methodID); minfo.env-&gt;DeleteLocalRef(minfo.classID);&#125; #endif &#125; 我们会在原工程右下角调用登录方法，需要修改HelloWorldScence.cpp 1234567#include \"SDK360.h\" ... void HelloWorld::menuCloseCallback(Ref* pSender) &#123; SDK360::getInstance()-&gt;login(); &#125; 最后在工程目录下jni-Android.mk 调用刚写好的SDK360.cpp 1234LOCAL_SRC_FILES := hellocpp/main.cpp \\ ../../Classes/AppDelegate.cpp \\ ../../Classes/SDK360.cpp \\ ../../Classes/HelloWorldScene.cpp 修改过c++文件都要重新编译一下.so文件执行build_native.py 编译成功后你就可以run运行起来了。 ps: 调用360支付也同样道理. Demo下载。","categories":[],"tags":[{"name":"Cocos2dx","slug":"Cocos2dx","permalink":"http://www.lanyimi.com/source/tags/Cocos2dx/"}]},{"title":"VirtualBox 遇到VERR _INTNET _FLT _IF _NOT _FOUND","slug":"VirtualBox无法运行","date":"2015-12-10T01:39:47.000Z","updated":"2016-11-22T09:09:16.428Z","comments":true,"path":"2015/12/10/VirtualBox无法运行/","link":"","permalink":"http://www.lanyimi.com/2015/12/10/VirtualBox无法运行/","excerpt":"","text":"解决win10升级TH2后 VirtualBox出现VERR _INTNET _FLT _IF _NOT _FOUND问题出自 http://tieba.baidu.com/p/4177034202 http://superuser.com/questions/1002160/failed-to-start-virtual-device-in-oracle-virtual-box 问题描述win10升级TH2后virtualbox无法正常运行，virtualbox关键错误VERR _INTNET _FLT _IF _NOT _FOUND 解决办法打开 网络和共享中心-更改适配器设置-选择VirtualBox Host-Only Network-右击属性 把VirtualBox NDIS6 Bridged Networking Driver 选择上就OK可以运行genymotion了","categories":[],"tags":[{"name":"Genymotion","slug":"Genymotion","permalink":"http://www.lanyimi.com/source/tags/Genymotion/"}]}]}